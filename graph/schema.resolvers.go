package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"
	"math"
	"strconv"

	"github.com/Chrisentech/aluta-market-api/app"
	"github.com/Chrisentech/aluta-market-api/graph/model"
	"github.com/Chrisentech/aluta-market-api/internals/cart"
	"github.com/Chrisentech/aluta-market-api/internals/product"
	"github.com/Chrisentech/aluta-market-api/internals/skynet"
	"github.com/Chrisentech/aluta-market-api/internals/store"
	"github.com/Chrisentech/aluta-market-api/internals/user"
	"github.com/Chrisentech/aluta-market-api/middlewares"
	"github.com/Chrisentech/aluta-market-api/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	userReq := &user.CreateUserReq{
		Fullname: input.Fullname,
		Email:    input.Email,
		Campus:   input.Campus,
		Password: input.Password,
		Phone:    input.Phone,
		Usertype: input.Usertype,
		// Code:       input.Code,
	}
	if input.Usertype == "seller" {
		userReq.StoreName = input.Stores.Name
		userReq.StoreLink = input.Stores.Link
		userReq.StoreAddress = input.Stores.Address
		userReq.Description = input.Stores.Description
		userReq.HasPhysicalAddress = input.Stores.HasPhysicalAddress
		userReq.Phone = input.Stores.Phone
	}
	_, err := userHandler.CreateUser(ctx, userReq)

	if err != nil {
		return nil, err
	}
	user := &model.User{
		Fullname: input.Fullname,
		Email:    input.Email,
		Campus:   input.Campus,
		Password: input.Password,
		Phone:    input.Phone,
		Usertype: input.Usertype,
	}
	// Append the newly created store to the user's Stores slice
	// user.Stores = append(user.Stores,input.Stores.ID)
	// user.Stores = append(user.Stores,input.St)
	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input *model.UpdateUserInput) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	usr := &user.User{}
	if input.Fullname != nil {
		usr.Fullname = *input.Fullname
	}
	if input.Email != nil {
		usr.Email = *input.Email
	}
	if input.Avatar != nil {
		usr.Avatar = *input.Avatar
	}
	if input.Phone != nil {
		usr.Phone = *input.Phone
	}
	if input.Gender != nil {
		usr.Phone = *input.Gender
	}
	if input.Dob != nil {
		usr.Phone = *input.Dob
	}
	if input.Usertype != nil {
		usr.Usertype = *input.Usertype
	}

	if input.ID != nil {
		idUint64, err := strconv.ParseUint(*input.ID, 10, 32)
		if err != nil {
			fmt.Println("Error converting ID:", err)
		} else {
			usr.ID = uint32(idUint64)
		}
	}
	resp, err := userHandler.UpdateUser(ctx, usr)

	if err != nil {
		return nil, err
	}
	modalResp := &model.User{
		ID:       strconv.FormatUint(uint64(resp.ID), 10),
		Fullname: resp.Fullname,
		Email:    resp.Email,
		Avatar:   &resp.Avatar,
		Phone:    resp.Phone,
		Usertype: resp.Usertype,
	}
	return modalResp, nil
}

// CreateVerifyOtp is the resolver for the createVerifyOTP field.
func (r *mutationResolver) CreateVerifyOtp(ctx context.Context, input model.NewVerifyOtp) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)

	req := &user.User{
		Phone: input.Phone,
		// Email: *input.Email,
		Code: input.Code,
	}
	resp, err := userHandler.VerifyOTP(ctx, req)
	if err != nil {
		return nil, err
	}
	schema := &model.User{
		Fullname: resp.Fullname,
		Email:    resp.Email,
		Campus:   resp.Campus,
		Password: resp.Password,
		Phone:    resp.Phone,
		Usertype: resp.Usertype,
		Active:   *resp.Active,
	}
	return schema, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginReq) (*model.LoginRes, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	req := &user.LoginUserReq{
		Email:    input.Email,
		Password: input.Password,
	}
	resp, err := userHandler.Login(ctx, req)
	if err != nil {
		return nil, err
	}
	schema := &model.LoginRes{
		ID:           int(resp.ID),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
	}
	return schema, nil
}

// AddHandledProduct is the resolver for the addHandledProduct field.
func (r *mutationResolver) AddHandledProduct(ctx context.Context, userID int, productID int, typeArg string) (*model.HandledProducts, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	prod, err := productHandler.AddHandledProduct(ctx, uint32(userID), uint32(productID), typeArg)
	if err != nil {
		return nil, err
	}
	schema := &model.HandledProducts{
		UserID:      userID,
		ProductID:   productID,
		ProductName: &prod.Product.Name,
	}
	return schema, nil
}

// AddReview is the resolver for the addReview field.
func (r *mutationResolver) AddReview(ctx context.Context, input model.ReviewInput) (*model.Review, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("", token)
	if authErr != nil {
		return nil, authErr
	}
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newReview := &product.Review{
		Username:  input.Username,
		Image:     input.Image,
		Message:   input.Message,
		Rating:    input.Rating,
		ProductID: uint32(input.ProductID),
	}
	resp, err := productHandler.AddReview(ctx, newReview)
	if err != nil {
		return nil, err
	}
	NewReview := &model.Review{
		Username:  resp.Username,
		Image:     resp.Image,
		Message:   resp.Message,
		Rating:    resp.Rating,
		ProductID: int(resp.ProductID),
	}

	return NewReview, nil
}

// CreateSkynet is the resolver for the createSkynet field.
func (r *mutationResolver) CreateSkynet(ctx context.Context, input *model.SkynetInput) (string, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("", token)
	// if authErr != nil {
	// 	return "", authErr
	// }
	skynetRep := app.InitializePackage(app.SkynetPackage)

	skynetRepository, ok := skynetRep.(skynet.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return "", fmt.Errorf("skynetRep is not a skynet.Repository")
	}
	skynetSrvc := skynet.NewService(skynetRepository)
	skynetHandler := skynet.NewHandler(skynetSrvc)
	skynetAirtimeInput := &skynet.Airtime{}
	skynetDataInput := &skynet.Data{}
	skynetTVSubInput := &skynet.TVSubscription{}
	skynetEducationInput := &skynet.EducationPayment{}

	if input.Type == "airtime" {
		skynetAirtimeInput.Amount = int64(input.Amount)
		skynetAirtimeInput.UserID = uint32(input.UserID)
		skynetAirtimeInput.ServiceID = input.ServiceID
		skynetAirtimeInput.Phone = *input.PhoneNumber

		resp, err := skynetHandler.BuyAirtime(ctx, skynetAirtimeInput)
		if err != nil {
			return "", err
		}
		return *resp, nil
	}
	if input.Type == "data" {
		skynetDataInput.Amount = int64(input.Amount)
		skynetDataInput.UserID = uint32(input.UserID)
		skynetDataInput.ServiceID = input.ServiceID
		skynetDataInput.Phone = *input.PhoneNumber
		skynetDataInput.BillersCode = *input.BillersCode
		skynetDataInput.VariationCode = *input.VariantCode

		resp, err := skynetHandler.BuyData(ctx, skynetDataInput)
		if err != nil {
			return "", err
		}
		return *resp, nil
	}

	if input.Type == "tv_sub" {
		skynetTVSubInput.Amount = int64(input.Amount)
		skynetTVSubInput.UserID = uint32(input.UserID)
		skynetTVSubInput.ServiceID = input.ServiceID
		skynetTVSubInput.Phone = *input.PhoneNumber
		skynetTVSubInput.BillersCode = *input.BillersCode
		skynetTVSubInput.VariationCode = *input.VariantCode
		skynetTVSubInput.SubscriptionType = *input.SubscriptionType

		resp, err := skynetHandler.BuyTVSubscription(ctx, skynetTVSubInput)
		if err != nil {
			return "", err
		}
		return *resp, nil
	}

	if input.Type == "education" {
		skynetEducationInput.Amount = int64(input.Amount)
		skynetEducationInput.UserID = uint32(input.UserID)
		skynetEducationInput.ServiceID = input.ServiceID
		skynetEducationInput.Phone = *input.PhoneNumber
		skynetEducationInput.BillersCode = *input.BillersCode
		skynetEducationInput.VariationCode = *input.VariantCode
		skynetEducationInput.Quantity = *input.Quantity

		resp, err := skynetHandler.BuyTVSubscription(ctx, skynetTVSubInput)
		if err != nil {
			return "", err
		}
		return *resp, nil
	}
	return "", errors.New("type is required")
}

// RemoveHandledProduct is the resolver for the removeHandledProduct field.
func (r *mutationResolver) RemoveHandledProduct(ctx context.Context, user int, typeArg *string) (*model.HandledProducts, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("", token)
	if authErr != nil {
		return nil, authErr
	}
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	err := productHandler.RemoveHandledProduct(ctx, uint32(user), *typeArg)
	if err != nil {
		return nil, err
	}
	schema := &model.HandledProducts{
		UserID: user,
	}
	return schema, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.NewCategory) (*model.Category, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("admin", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newCategory := &product.Category{
		Name: input.Name,
	}
	resp, err := productHandler.CreateCategory(ctx, newCategory)
	if err != nil {
		return nil, err
	}
	schema := &model.Category{
		Name: resp.Name,
		Slug: utils.GenerateSlug(resp.Name),
	}
	return schema, nil
}

// CreateSubCategory is the resolver for the createSubCategory field.
func (r *mutationResolver) CreateSubCategory(ctx context.Context, input model.NewSubCategory) (*model.SubCategory, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("admin", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newSubCategory := product.SubCategory{
		Name:       input.Name,
		CategoryID: uint32(input.Category),
	}
	resp, err := productHandler.CreateSubCategory(ctx, newSubCategory)
	if err != nil {
		return nil, err
	}
	schema := &model.SubCategory{
		Name:     resp.Name,
		Slug:     utils.GenerateSlug(resp.Name),
		Category: input.Category,
	}
	return schema, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	productRep := app.InitializePackage(app.ProductPackage)
	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)

	// Create a new product
	newProduct := &product.NewProduct{
		Name:          input.Name,
		Description:   input.Description,
		Images:        input.Image,
		Price:         input.Price,
		Discount:      input.Discount,
		Quantity:      input.Quantity,
		Status:        true,
		Thumbnail:     input.Thumbnail,
		CategoryID:    uint8(input.Category),
		SubCategoryID: uint8(input.Subcategory),
		Store:         input.Store,
	}

	// Create product variants and their values
	for _, variantInput := range input.Variant {
		productVariant := &product.VariantType{Name: variantInput.Name}
		var variantValues []*product.VariantValue

		for _, val := range variantInput.Value {
			variantValue := &product.VariantValue{
				Value:  val.Value,
				Price:  *val.Price,
				Images: val.Images,
			}
			variantValues = append(variantValues, variantValue)
		}

		productVariant.Value = variantValues
		newProduct.Variant = append(newProduct.Variant, productVariant)
	}

	// Create the product using the handler
	resp, err := productHandler.CreateProduct(ctx, newProduct)
	if err != nil {
		return nil, err
	}

	// Transform and return the response
	schema := &model.Product{
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Images,
		Price:       resp.Price,
		Discount:    resp.Discount,
		Status:      true,
		Slug:        utils.GenerateSlug(resp.Name),
		Thumbnail:   resp.Thumbnail,
		Category:    resp.Category,
		Store:       resp.Store,
		Subcategory: resp.Subcategory,
	}

	if len(resp.Variant) != 0 {
		for _, outerItem := range resp.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			schema.Variant = append(schema.Variant, productVariant)
		}
	}

	return schema, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input *model.ProductInput) (*model.Product, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	productRep := app.InitializePackage(app.ProductPackage)
	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	mod := &product.Product{}

	resp, err := productHandler.UpdateProduct(ctx, mod)
	if err != nil {
		return nil, err
	}

	modResp := &model.Product{
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Images,
		Price:       resp.Price,
		Status:      resp.Status,
		Quantity:    resp.Quantity,
		Slug:        resp.Slug,
		Store:       resp.Store,
		Category:    resp.Category,
		Subcategory: resp.Subcategory,
		Thumbnail:   resp.Thumbnail,
	}
	if len(resp.Variant) != 0 {
		for _, outerItem := range resp.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			modResp.Variant = append(modResp.Variant, productVariant)
		}
	}

	if len(resp.Reviews) != 0 {
		for _, review := range resp.Reviews {
			modelReview := &model.Review{
				Rating:    review.Rating,
				Message:   review.Message,
				Image:     review.Image,
				ProductID: int(review.ProductID), //to be reviewed later
				ID:        &review.ID,
				Username:  review.Username,
			}
			modResp.Review = append(modResp.Review, modelReview)
		}
	}

	panic(fmt.Errorf("not implemented: UpdateProduct - updateProduct"))
}

// ToggleStoreFollowStatus is the resolver for the toggleStoreFollowStatus field.
func (r *mutationResolver) ToggleStoreFollowStatus(ctx context.Context, user int, store int) (*string, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	panic(fmt.Errorf("not implemented: ToggleStoreFollowStatus - toggleStoreFollowStatus"))
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, productID int) (*model.Product, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("seller", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	productRep := app.InitializePackage(app.ProductPackage)
	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	product, _ := productHandler.GetProduct(ctx, uint32(productID), 0)
	modPrd := &model.Product{
		Name: product.Name,
	}
	err := productHandler.DeleteProduct(ctx, uint32(productID))
	if err != nil {
		return nil, err
	}

	return modPrd, nil
}

// ModifyCart is the resolver for the ModifyCart field.
func (r *mutationResolver) ModifyCart(ctx context.Context, input model.ModifyCartItemInput) (*model.Cart, error) {
	var cartItem cart.CartItems
	cartItem.Quantity = input.Quantity
	num, _ := strconv.ParseUint(input.ProductID, 10, 32)
	cartItem.Product = &product.Product{ID: uint32(num)}

	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)

	resp, err := cartHandler.ModifyCart(ctx, &cartItem, uint32(input.User))

	if err != nil {
		// Handle the error, possibly by logging it or returning it to the client
		return nil, err
	}
	var modelCartItems []*model.CartItem
	for _, item := range resp.Items {
		modelProduct := &model.Product{
			ID:        int(item.Product.ID),
			Quantity:  item.Product.Quantity,
			Price:     item.Product.Price,
			Discount:  item.Product.Discount,
			Name:      item.Product.Name,
			Thumbnail: item.Product.Thumbnail,
			Image:     item.Product.Images,
			Store:     item.Product.Store,
		}

		modelItem := &model.CartItem{
			Product:  modelProduct,
			Quantity: int(item.Quantity),
		}

		modelCartItems = append(modelCartItems, modelItem)
	}
	// Now you need to construct the cart object with the accumulated cartItems
	newCart := &model.Cart{
		// Set the appropriate values for Total, User, and Active
		Total:  resp.Total,       // Replace with the actual total
		User:   int(resp.UserID), // Replace with the actual user ID
		Active: true,             // Replace with the actual active status
		Items:  modelCartItems,
		ID:     uint32ToStringPtr(resp.ID),
	}

	return newCart, nil
}

// RemoveAllCart is the resolver for the removeAllCart field.
func (r *mutationResolver) RemoveAllCart(ctx context.Context, cartID int) (*model.Cart, error) {
	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	err := cartHandler.RemoveAllCart(ctx, uint32(cartID))
	if err != nil {
		return nil, err
	}
	deletedCart := &model.Cart{}
	return deletedCart, nil
}

// CreateStore is the resolver for the createStore field.
func (r *mutationResolver) CreateStore(ctx context.Context, input model.StoreInput) (*model.Store, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("", token)
	if authErr != nil {
		return nil, authErr
	}
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a cart.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	mod := &store.Store{
		Name:               input.Name,
		UserID:             uint32(input.User),
		Link:               input.Link,
		Description:        input.Description,
		HasPhysicalAddress: input.HasPhysicalAddress,
		Address:            input.Address,
		Wallet:             float64(input.Wallet),
		Status:             input.Status,
	}
	if input.Address != "" {
		mod.HasPhysicalAddress = true
	}
	if input.Thumbnail != nil {
		mod.Thumbnail = *input.Thumbnail
	}
	if input.Background != nil {
		mod.Background = *input.Background
	}
	resp, err := storeHandler.CreateStore(ctx, mod)
	if err != nil {
		return nil, err
	}
	storeMod := &model.Store{
		Name:               resp.Name,
		User:               int(resp.UserID),
		Description:        resp.Description,
		Link:               resp.Link,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Address:            resp.Address,
		Wallet:             resp.Wallet,
		Thumbnail:          resp.Thumbnail,
		Background:         resp.Background,
	}

	return storeMod, nil
}

// UpdateStore is the resolver for the updateStore field.
func (r *mutationResolver) UpdateStore(ctx context.Context, input *model.UpdateStoreInput) (*model.Store, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a cart.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	mod := &store.Store{}

	if input.Name != nil {
		return nil, errors.New("Store name cannot be changed after being created")
	}
	if input.Link != nil {
		mod.Link = *input.Link
	}
	if input.Description != nil {
		mod.Description = *input.Description
	}

	if input.Address != nil {
		mod.Address = *input.Address
		mod.HasPhysicalAddress = true
	}
	if input.Wallet != nil {
		mod.Wallet = float64(*input.Wallet)
	}
	if input.Thumbnail != nil {
		mod.Thumbnail = *input.Thumbnail
	}
	if input.Phone != nil {
		mod.Phone = *input.Phone
	}
	if input.Email != nil {
		mod.Email = *input.Email
	}
	if input.Background != nil {
		mod.Background = *input.Background
	}
	if input.ID != nil {
		idUint64, err := strconv.ParseUint(*input.ID, 10, 32)
		if err != nil {
			fmt.Println("Error converting ID:", err)
		} else {
			mod.ID = uint32(idUint64)
		}
	}
	if input.Status != nil {
		mod.Status = *input.Status
	}

	resp, err := storeHandler.UpdateStore(ctx, mod)
	if err != nil {
		return nil, err
	}
	modalResp := &model.Store{
		ID:                 strconv.FormatUint(uint64(resp.ID), 10),
		Name:               resp.Name,
		Link:               resp.Link,
		Description:        resp.Description,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Background:         resp.Background,
		Thumbnail:          resp.Thumbnail,
		// Email: resp.Email,
		Status: resp.Status,
	}
	return modalResp, nil
}

// DeleteStore is the resolver for the deleteStore field.
func (r *mutationResolver) DeleteStore(ctx context.Context, storeID int) (*model.Store, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("", token)
	if authErr != nil {
		return nil, authErr
	}
	panic(fmt.Errorf("not implemented: DeleteStore - deleteStore"))
}

// CreateDVAAccount is the resolver for the createDVAAccount field.
func (r *mutationResolver) CreateDVAAccount(ctx context.Context, input model.DVAAccountInput) (string, error) {
	// 	token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return "", authErr
	// }
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return "", fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	modelInput := user.DVADetails{
		BVN:           input.Bvn,
		Country:       input.Country,
		AccountNumber: input.AccountNumber,
		BankCode:      input.BankCode,
		UserID:        input.UserID,
		StoreName:     input.StoreName,
	}
	resp, err := userHandler.CreateDVAAccount(ctx, &modelInput)
	if err != nil {
		return "", err
	}
	return resp, nil
}

// InitializePayment is the resolver for the initializePayment field.
func (r *mutationResolver) InitializePayment(ctx context.Context, input model.PaymentData) (*string, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	paymentOrder := &store.Order{
		Fee:            10.56,
		UserID:         input.UserID,
		PaymentGateway: input.PaymentGateway,
	}
	resp, err := cartHandler.InitiatePayment(ctx, paymentOrder)
	if err != nil {
		return nil, err
	}
	return &resp, err
}

// VerifySmartCard is the resolver for the verifySmartCard field.
func (r *mutationResolver) VerifySmartCard(ctx context.Context, input model.SmartCardInput) (*model.SmartcardVerificationResponse, error) {
	skynetRep := app.InitializePackage(app.SkynetPackage)

	skynetRepository, ok := skynetRep.(skynet.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("skynetRep is not a skynet.Repository")
	}
	skynetSrvc := skynet.NewService(skynetRepository)
	skynetHandler := skynet.NewHandler(skynetSrvc)
	resp, err := skynetHandler.VerifySmartCard(ctx, input.ServiceID, input.BillersCode, *input.CardType)

	if err != nil {
		return nil, err
	}

	// Map the response to the GraphQL model
	verificationResponse := &model.SmartcardVerificationResponse{
		Code: resp.Code,
		Content: &model.SmartcardContent{
			CustomerName:       resp.Content.CustomerName,
			Status:             resp.Content.Status,
			DueDate:            resp.Content.DueDate,
			CustomerNumber:     resp.Content.CustomerNumber,
			CustomerType:       resp.Content.CustomerType,
			CurrentBouquet:     resp.Content.CurrentBouquet,
			CurrentBouquetCode: resp.Content.CurrentBouquetCode,
			RenewalAmount:      resp.Content.RenewalAmount,
		},
	}

	return verificationResponse, nil
}

// Users is the resolver for the Users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	resp, err := userHandler.GetUsers(ctx)
	if err != nil {
		return nil, err
	}

	var users []*model.User

	// Assuming resp is a slice of users
	for _, item := range resp {
		accessToken := item.AccessToken
		refreshToken := item.RefreshToken

		user := &model.User{
			ID:           strconv.FormatInt(int64(item.ID), 10),
			Fullname:     item.Fullname,
			Campus:       item.Campus,
			Email:        item.Email,
			Phone:        item.Phone,
			Twofa:        *item.Twofa,
			Active:       *item.Active,
			AccessToken:  &accessToken,
			RefreshToken: &refreshToken,
			Usertype:     item.Usertype,
			Code:         item.Code,
			Avatar:       &item.Avatar,
			// Codeexpiry: item.Codeexpiry.Format(time.RFC3339),
			Password: "lol......what do y'need it for?",
		}

		users = append(users, user)
	}

	return users, nil
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	resp, err := userHandler.GetUser(ctx, id)
	if err != nil {
		return nil, err
	}
	accessToken := resp.AccessToken
	refreshToken := resp.RefreshToken

	user := &model.User{
		ID:           strconv.FormatInt(int64(resp.ID), 10),
		Fullname:     resp.Fullname,
		Campus:       resp.Campus,
		Email:        resp.Email,
		Phone:        resp.Phone,
		Twofa:        *resp.Twofa,
		Active:       *resp.Active,
		AccessToken:  &accessToken,
		RefreshToken: &refreshToken,
		Usertype:     resp.Usertype,
		Code:         resp.Code,
		Avatar:       &resp.Avatar,

		Password: "lol......what do y'need it for?",
	}

	return user, nil
}

// Categories is the resolver for the Categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetCategories(ctx)
	if err != nil {
		return nil, err
	}

	var categories []*model.Category

	// Assuming resp is a slice of categories
	for _, item := range resp {
		var subCategories []*model.SubCategory

		for _, subItem := range item.SubCategories {
			subCategory := &model.SubCategory{
				Name:     subItem.Name,
				Slug:     subItem.Slug,
				Category: int(subItem.CategoryID),
			}
			subCategories = append(subCategories, subCategory)
		}

		category := &model.Category{
			Name:          item.Name,
			Slug:          item.Slug,
			Subcategories: subCategories,
			ID:            strconv.Itoa(item.ID),
		}
		categories = append(categories, category)
	}
	return categories, nil
}

// Category is the resolver for the Category field.
func (r *queryResolver) Category(ctx context.Context, id int) (*model.Category, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetCategory(ctx, uint32(id))
	if err != nil {
		return nil, err
	}

	var category *model.Category
	var subCategories []*model.SubCategory
	for _, subItem := range resp.SubCategories {
		subCategory := &model.SubCategory{
			Name:     subItem.Name,
			Slug:     subItem.Slug,
			Category: int(subItem.CategoryID),
		}
		subCategories = append(subCategories, subCategory)
	}
	category = &model.Category{
		Name:          resp.Name,
		Slug:          resp.Slug,
		Subcategories: subCategories,
		ID:            strconv.Itoa(resp.ID),
	}
	return category, nil
}

// SubCategory is the resolver for the SubCategory field.
func (r *queryResolver) SubCategory(ctx context.Context, id string) (*model.SubCategory, error) {
	panic(fmt.Errorf("not implemented: SubCategory - SubCategory"))
}

// Products is the resolver for the Products field.
func (r *queryResolver) Products(ctx context.Context, store *string, limit *int, offset *int) (*model.ProductPaginationData, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)

	resp, count, err := productHandler.GetProducts(ctx, *store, *limit, *offset)
	if err != nil {
		return nil, err
	}

	var products []*model.Product

	// Assuming resp is a slice of products
	for _, item := range resp {
		id, _ := strconv.Atoi(strconv.FormatInt(int64(item.ID), 10))
		product := &model.Product{
			ID:          id,
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Images,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			Store:       item.Store,
			Thumbnail:   item.Thumbnail,
			Category:    item.Category,
			Subcategory: item.Subcategory,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
				productVariant := &model.Variant{}
				productVariant.Name = outerItem.Name
				variantValues := make([]*model.VariantValue, 0)

				for _, item := range outerItem.Value {
					modelVariantValue := &model.VariantValue{
						Value:  item.Value,
						Price:  item.Price,
						Images: item.Images,
					}
					variantValues = append(variantValues, modelVariantValue)
				}
				productVariant.Value = variantValues
				product.Variant = append(product.Variant, productVariant)
			}
		}

		if len(item.Reviews) != 0 {
			for _, review := range item.Reviews {
				modelReview := &model.Review{
					Rating:    review.Rating,
					Message:   review.Message,
					Image:     review.Image,
					ProductID: int(review.ProductID), //to be reviewed later
					ID:        &review.ID,
					Username:  review.Username,
				}
				product.Review = append(product.Review, modelReview)
			}
		}
		products = append(products, product)
	}
	currentPage := *offset + 1
	totalPages := int(math.Ceil(float64(count) / float64(*limit)))
	nextPage := 0
	if currentPage < totalPages {
		nextPage = currentPage + 1
	}
	prevPage := 0
	if currentPage > 1 {
		prevPage = currentPage - 1
	}

	payload := &model.ProductPaginationData{
		Data:        products,
		CurrentPage: currentPage,
		PerPage:     *limit,
		Total:       count,
		NextPage:    nextPage,
		PrevPage:    prevPage,
	}

	return payload, nil
}

// Product is the resolver for the Product field.
func (r *queryResolver) Product(ctx context.Context, id int) (*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetProduct(ctx, uint32(id), 0)
	if err != nil {
		return nil, err
	}

	product := &model.Product{
		// ID:       strconv.FormatInt(int64(resp.ID), 10),
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Images,
		Price:       resp.Price,
		Status:      resp.Status,
		Quantity:    resp.Quantity,
		Slug:        resp.Slug,
		Store:       resp.Store,
		Category:    resp.Category,
		Subcategory: resp.Subcategory,
		Thumbnail:   resp.Thumbnail,
	}
	if len(resp.Variant) != 0 {
		for _, outerItem := range resp.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			product.Variant = append(product.Variant, productVariant)
		}
	}

	if len(resp.Reviews) != 0 {
		for _, review := range resp.Reviews {
			modelReview := &model.Review{
				Rating:    review.Rating,
				Message:   review.Message,
				Image:     review.Image,
				ProductID: int(review.ProductID), //to be reviewed later
				ID:        &review.ID,
				Username:  review.Username,
			}
			product.Review = append(product.Review, modelReview)
		}
	}

	return product, nil
}

// HandledProducts is the resolver for the HandledProducts field.
func (r *queryResolver) HandledProducts(ctx context.Context, user int, typeArg string) ([]*model.HandledProducts, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetHandledProducts(ctx, uint32(user), typeArg)
	if err != nil {
		return nil, err
	}
	prds := []*model.HandledProducts{}
	for i, item := range resp {
		prd := &model.HandledProducts{
			ProductID:        int(item.Product.ID),
			ProductName:      &item.Product.Name,
			ProductDiscount:  &item.Product.Discount,
			ProductPrice:     &item.Product.Price,
			ProductThumbnail: &item.Product.Thumbnail,
			ProductQuantity:  &item.Product.Quantity,
			ProductStatus:    &item.Product.Status,
			UserID:           int(resp[i].UserID),
		}
		prds = append(prds, prd)
	}
	return prds, nil
}

// RecommendedProducts is the resolver for the RecommendedProducts field.
func (r *queryResolver) RecommendedProducts(ctx context.Context, query string) ([]*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetRecommendedProducts(ctx, query)
	if err != nil {
		return nil, err
	}
	var products []*model.Product

	for _, item := range resp {
		product := &model.Product{
			// ID:       strconv.FormatInt(int64(item.ID), 10),
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Images,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			// Variant:     item.Variant,
			Store:       item.Store,
			Category:    item.Category,
			Subcategory: item.Subcategory,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
				productVariant := &model.Variant{}
				productVariant.Name = outerItem.Name
				variantValues := make([]*model.VariantValue, 0)

				for _, item := range outerItem.Value {
					modelVariantValue := &model.VariantValue{
						Value:  item.Value,
						Price:  item.Price,
						Images: item.Images,
					}
					variantValues = append(variantValues, modelVariantValue)
				}
				productVariant.Value = variantValues
				product.Variant = append(product.Variant, productVariant)

			}
		}
		products = append(products, product)
	}
	return products, nil
}

// RecentlyAddedProducts is the resolver for the RecentlyAddedProducts field.
func (r *queryResolver) RecentlyAddedProducts(ctx context.Context, user int) ([]*model.Product, error) {
	panic(fmt.Errorf("not implemented: RecentlyAddedProducts - RecentlyAddedProducts"))
}

// ProductReviews is the resolver for the ProductReviews field.
func (r *queryResolver) ProductReviews(ctx context.Context, id int) ([]*model.Review, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetReviews(ctx, uint32(id))
	if err != nil {
		return nil, err
	}
	var reviews []*model.Review
	for _, item := range resp {
		review := &model.Review{
			Username:  item.Username,
			Image:     item.Image,
			Message:   item.Message,
			Rating:    item.Rating,
			ProductID: int(item.ProductID),
		}
		reviews = append(reviews, review)
	}
	return reviews, nil
}

// Cart is the resolver for the Cart field.
func (r *queryResolver) Cart(ctx context.Context, user int) (*model.Cart, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	cartRep := app.InitializePackage(app.CartPackage)
	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		panic("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	resp, err := cartHandler.GetCart(ctx, uint32(user))
	if err != nil {
		return nil, err
	}
	var modelCartItems []*model.CartItem

	for _, item := range resp.Items {
		modelProduct := &model.Product{
			ID:          int(item.Product.ID),
			Quantity:    item.Product.Quantity,
			Name:        item.Product.Name,
			Description: item.Product.Description,
			Price:       item.Product.Price,
			Thumbnail:   item.Product.Thumbnail,
			Image:       item.Product.Images,
			Discount:    item.Product.Discount,
			Category:    item.Product.Category,
			Status:      item.Product.Status,
			Store:       item.Product.Store,
		}
		if len(item.Product.Variant) != 0 {
			for _, outerItem := range item.Product.Variant {
				productVariant := &model.Variant{}
				productVariant.Name = outerItem.Name
				variantValues := make([]*model.VariantValue, 0)

				for _, item := range outerItem.Value {
					modelVariantValue := &model.VariantValue{
						Value:  item.Value,
						Price:  item.Price,
						Images: item.Images,
					}
					variantValues = append(variantValues, modelVariantValue)
				}
				productVariant.Value = variantValues
				modelProduct.Variant = append(modelProduct.Variant, productVariant)

			}
		}
		modelItem := &model.CartItem{
			Product:  modelProduct,
			Quantity: int(item.Quantity),
		}
		modelCartItems = append(modelCartItems, modelItem)
	}

	// var items []*model.CartItem
	cart := &model.Cart{
		Total:  resp.Total,
		Items:  modelCartItems,
		Active: resp.Active,
		ID:     uint32ToStringPtr(resp.ID),
		User:   int(resp.UserID),
	}
	return cart, nil
}

// SubscriptionBundle is the resolver for the SubscriptionBundle field.
func (r *queryResolver) SubscriptionBundle(ctx context.Context, serviceID string) (*model.SubscriptionBundle, error) {
	skynetRep := app.InitializePackage(app.SkynetPackage)

	skynetRepository, ok := skynetRep.(skynet.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("skynetRep is not a skynet.Repository")
	}
	skynetSrvc := skynet.NewService(skynetRepository)
	skynetHandler := skynet.NewHandler(skynetSrvc)
	resp, err := skynetHandler.GetSubscriptionsBundles(ctx, serviceID)
	if err != nil {
		return nil, err
	}
	var variations []*model.BundleVariation
	for _, v := range resp.Variations {
		variation := &model.BundleVariation{
			VariationCode:   v.VariationCode,
			Name:            v.Name,
			VariationAmount: v.VariationAmount,
			FixedPrice:      v.FixedPrice,
		}
		variations = append(variations, variation)
	}

	response := &model.SubscriptionBundle{
		ServiceName:    resp.ServiceName,
		ServiceID:      resp.ServiceID,
		ConvinienceFee: resp.ConvinienceFee,
		Variations:     variations,
	}

	return response, nil
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, query string) ([]*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.SearchProducts(ctx, query)
	if err != nil {
		return nil, err
	}
	var products []*model.Product

	for _, item := range resp {
		product := &model.Product{
			ID:          int(int64(item.ID)),
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Images,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			Store:       item.Store,
			Category:    item.Category,
			Subcategory: item.Subcategory,
			Thumbnail:   item.Thumbnail,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
				productVariant := &model.Variant{}
				productVariant.Name = outerItem.Name
				variantValues := make([]*model.VariantValue, 0)

				for _, item := range outerItem.Value {
					modelVariantValue := &model.VariantValue{
						Value:  item.Value,
						Price:  item.Price,
						Images: item.Images,
					}
					variantValues = append(variantValues, modelVariantValue)
				}
				productVariant.Value = variantValues
				product.Variant = append(product.Variant, productVariant)

			}
		}
		if len(item.Reviews) != 0 {
			for _, review := range item.Reviews {
				modelReview := &model.Review{
					Rating:    review.Rating,
					Message:   review.Message,
					Image:     review.Image,
					ProductID: int(review.ProductID), //to be reviewed later
					ID:        &review.ID,
					Username:  review.Username,
				}
				product.Review = append(product.Review, modelReview)
			}
		}
		products = append(products, product)
	}
	return products, nil
}

// Stores is the resolver for the Stores field.
func (r *queryResolver) Stores(ctx context.Context, user *int, limit *int, offset *int) (*model.StorePaginationData, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)
	resp, err := storeHandler.GetStores(ctx, uint32(*user), *limit, *offset)
	var stores []*model.Store
	if err != nil {
		return nil, err
	}
	for _, item := range resp {
		id, _ := strconv.Atoi(strconv.FormatInt(int64(item.ID), 10))

		store := &model.Store{
			ID:                 strconv.Itoa(id),
			Name:               item.Name,
			HasPhysicalAddress: item.HasPhysicalAddress,
			Link:               item.Link,
			Wallet:             item.Wallet,
			User:               int(item.UserID),
			Description:        item.Description,
			Thumbnail:          item.Thumbnail,
			Background:         item.Background,
			Phone:              item.Phone,
			Address:            item.Address,
			Email:              item.Email,
		}
		if len(item.Followers) > 0 {
			for _, follower := range item.Followers {
				storeFollower := &model.Follower{}
				storeFollower.FollowerID = int(follower.ID)
				storeFollower.FollowerName = follower.FollowerName
				store.Followers = append(store.Followers, storeFollower)
			}
		}
		stores = append(stores, store)

	}
	payload := &model.StorePaginationData{
		Data:        stores,
		CurrentPage: *offset + 1,
		PerPage:     *limit,
		Total:       len(resp),
	}
	return payload, nil
}

// Store is the resolver for the Store field.
func (r *queryResolver) Store(ctx context.Context, id int) (*model.Store, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("seller", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }

	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	resp, err := storeHandler.GetStore(ctx, uint32(id))

	if err != nil {
		return nil, err
	}
	storeId, _ := strconv.Atoi(strconv.FormatInt(int64(resp.ID), 10))

	store := &model.Store{
		ID:                 strconv.Itoa(storeId),
		Name:               resp.Name,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Link:               resp.Link,
		Wallet:             resp.Wallet,
		User:               int(resp.UserID),
		Description:        resp.Description,
		Thumbnail:          resp.Thumbnail,
		Background:         resp.Background,
		Address:            resp.Address,
		Phone:              resp.Phone,
	}
	for _, follower := range resp.Followers {
		storeFollower := &model.Follower{}
		storeFollower.FollowerID = int(follower.ID)
		storeFollower.FollowerName = follower.FollowerName
		store.Followers = append(store.Followers, storeFollower)
	}

	return store, nil
}

// StoreByName is the resolver for the StoreByName field.
func (r *queryResolver) StoreByName(ctx context.Context, name string) (*model.Store, error) {
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	resp, err := storeHandler.GetStoreByName(ctx, name)

	if err != nil {
		return nil, err
	}
	storeId, _ := strconv.Atoi(strconv.FormatInt(int64(resp.ID), 10))

	store := &model.Store{
		ID:                 strconv.Itoa(storeId),
		Name:               resp.Name,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Link:               resp.Link,
		Wallet:             resp.Wallet,
		User:               int(resp.UserID),
		Description:        resp.Description,
		Thumbnail:          resp.Thumbnail,
	}
	for _, follower := range resp.Followers {
		storeFollower := &model.Follower{}
		storeFollower.FollowerID = int(follower.ID)
		storeFollower.FollowerName = follower.FollowerName
		store.Followers = append(store.Followers, storeFollower)
	}

	return store, nil
}

// Skynets is the resolver for the Skynets field.
func (r *queryResolver) Skynets(ctx context.Context, id string) ([]*model.Skynet, error) {
	panic(fmt.Errorf("not implemented: Skynets - Skynets"))
}

// Skynet is the resolver for the Skynet field.
func (r *queryResolver) Skynet(ctx context.Context, id string) (*model.Skynet, error) {
	panic(fmt.Errorf("not implemented: Skynet - Skynet"))
}

// ProductSearchResults is the resolver for the productSearchResults field.
func (r *subscriptionResolver) ProductSearchResults(ctx context.Context, query string) (<-chan []*model.Product, error) {
	panic(fmt.Errorf("not implemented: ProductSearchResults - productSearchResults"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func uint32ToStringPtr(value uint32) *string {
	strValue := strconv.FormatUint(uint64(value), 10)
	return &strValue
}
