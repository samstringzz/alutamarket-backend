package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"fmt"
	"strconv"

	"github.com/Chrisentech/aluta-market-api/app"
	"github.com/Chrisentech/aluta-market-api/graph/model"
	"github.com/Chrisentech/aluta-market-api/internals/cart"
	"github.com/Chrisentech/aluta-market-api/internals/product"
	"github.com/Chrisentech/aluta-market-api/internals/store"
	"github.com/Chrisentech/aluta-market-api/internals/user"
	"github.com/Chrisentech/aluta-market-api/middlewares"
	"github.com/Chrisentech/aluta-market-api/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	userReq := &user.CreateUserReq{
		Fullname: input.Fullname,
		Email:    input.Email,
		Campus:   input.Campus,
		Password: input.Password,
		Phone:    input.Phone,
		Usertype: input.Usertype,
		// Code:       input.Code,
	}
	if input.Usertype == "seller" {
		userReq.StoreName = input.Stores.Name
		userReq.StoreLink = input.Stores.Link
		userReq.StoreAddress = input.Stores.Address
		userReq.Description = input.Stores.Description
		userReq.HasPhysicalAddress = input.Stores.HasPhysicalAddress
		// userReq.Phone = input.Stores.Phone
	}
	_, err := userHandler.CreateUser(ctx, userReq)

	if err != nil {
		return nil, err
	}
	user := &model.User{
		Fullname: input.Fullname,
		Email:    input.Email,
		Campus:   input.Campus,
		Password: input.Password,
		Phone:    input.Phone,
		Usertype: input.Usertype,
	}
	// Append the newly created store to the user's Stores slice
	// user.Stores = append(user.Stores,input.Stores.ID)
	// user.Stores = append(user.Stores,input.St)
	return user, nil
}

// CreateVerifyOtp is the resolver for the createVerifyOTP field.
func (r *mutationResolver) CreateVerifyOtp(ctx context.Context, input model.NewVerifyOtp) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)

	req := &user.User{
		Phone: input.Phone,
		// Email: *input.Email,
		Code: input.Code,
	}
	resp, err := userHandler.VerifyOTP(ctx, req)
	if err != nil {
		return nil, err
	}
	schema := &model.User{
		Fullname: resp.Fullname,
		Email:    resp.Email,
		Campus:   resp.Campus,
		Password: resp.Password,
		Phone:    resp.Phone,
		Usertype: resp.Usertype,
		Active:   resp.Active,
	}
	return schema, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginReq) (*model.LoginRes, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	req := &user.LoginUserReq{
		Email:    input.Email,
		Password: input.Password,
	}
	resp, err := userHandler.Login(ctx, req)
	if err != nil {
		return nil, err
	}
	schema := &model.LoginRes{
		ID:           int(resp.ID),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
	}
	return schema, nil
}

// AddWishListedProduct is the resolver for the addWishListedProduct field.
func (r *mutationResolver) AddWishListedProduct(ctx context.Context, userID int, productID int) (*model.WishList, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	prod, err := productHandler.AddWishListedProduct(ctx, uint32(userID), uint32(productID))
	if err != nil {
		return nil, err
	}
	schema := &model.WishList{
		UserID:      userID,
		ProductID:   productID,
		ProductName: &prod.Product.Name,
	}
	return schema, nil
}

// RemoveWishListedProduct is the resolver for the removeWishListedProduct field.
func (r *mutationResolver) RemoveWishListedProduct(ctx context.Context, user int) (*model.WishList, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	err := productHandler.RemoveWishListedProduct(ctx, uint32(user))
	if err != nil {
		return nil, err
	}
	schema := &model.WishList{
		UserID: user,
	}
	return schema, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.NewCategory) (*model.Category, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newCategory := &product.Category{
		Name: input.Name,
	}
	resp, err := productHandler.CreateCategory(ctx, newCategory)
	if err != nil {
		return nil, err
	}
	schema := &model.Category{
		Name: resp.Name,
		Slug: utils.GenerateSlug(resp.Name),
	}
	return schema, nil
}

// CreateSubCategory is the resolver for the createSubCategory field.
func (r *mutationResolver) CreateSubCategory(ctx context.Context, input model.NewSubCategory) (*model.SubCategory, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newSubCategory := product.SubCategory{
		Name:       input.Name,
		CategoryID: uint32(input.Category),
	}
	resp, err := productHandler.CreateSubCategory(ctx, newSubCategory)
	if err != nil {
		return nil, err
	}
	schema := &model.SubCategory{
		Name:     resp.Name,
		Slug:     utils.GenerateSlug(resp.Name),
		Category: input.Category,
	}
	return schema, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.NewProduct) (*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)
	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)

	// Create a new product
	newProduct := &product.NewProduct{
		Name:          input.Name,
		Description:   input.Description,
		Images:        input.Image,
		Price:         input.Price,
		Discount:      input.Discount,
		Quantity:      input.Quantity,
		Status:        true,
		Thumbnail:     input.Thumbnail,
		CategoryID:    uint8(input.Category),
		SubCategoryID: uint8(input.Subcategory),
		Store:         input.Store,
	}

	// Create product variants and their values
	for _, variantInput := range input.Variant {
		productVariant := &product.VariantType{Name: variantInput.Name}
		var variantValues []*product.VariantValue

		for _, val := range variantInput.Value {
			variantValue := &product.VariantValue{
				Value:  val.Value,
				Price:  *val.Price,
				Images: val.Images,
			}
			variantValues = append(variantValues, variantValue)
		}

		productVariant.Value = variantValues
		newProduct.Variant = append(newProduct.Variant, productVariant)
	}

	// Create the product using the handler
	resp, err := productHandler.CreateProduct(ctx, newProduct)
	if err != nil {
		return nil, err
	}

	// Transform and return the response
	schema := &model.Product{
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Images,
		Price:       resp.Price,
		Discount:    resp.Discount,
		Status:      true,
		Slug:        utils.GenerateSlug(resp.Name),
		Thumbnail:   resp.Thumbnail,
		Category:    resp.Category,
		Store:       resp.Store,
		Subcategory: resp.Subcategory,
	}

	if len(resp.Variant) != 0 {
		for _, outerItem := range resp.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			schema.Variant = append(schema.Variant, productVariant)
		}
	}

	return schema, nil
}


// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input *model.NewProduct) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: UpdateProduct - updateProduct"))
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, productID int) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: DeleteProduct - deleteProduct"))
}

// ModifyCart is the resolver for the ModifyCart field.
func (r *mutationResolver) ModifyCart(ctx context.Context, input model.ModifyCartItemInput) (*model.Cart, error) {
	var cartItem cart.CartItems
	cartItem.Quantity = input.Quantity
	num, _ := strconv.ParseUint(input.ProductID, 10, 32)
	cartItem.Product = &product.Product{ID: uint32(num)}

	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)

	resp, err := cartHandler.ModifyCart(ctx, &cartItem, uint32(input.User))

	if err != nil {
		// Handle the error, possibly by logging it or returning it to the client
		return nil, err
	}
	var modelCartItems []*model.CartItem
	for _, item := range resp.Items {
		modelProduct := &model.Product{
			ID:       int(item.Product.ID),
			Quantity: item.Product.Quantity,
			Price:    item.Product.Price,
			Discount: item.Product.Discount,
			Name:     item.Product.Name,
		}

		modelItem := &model.CartItem{
			Product:  modelProduct,
			Quantity: int(item.Quantity),
		}

		modelCartItems = append(modelCartItems, modelItem)
	}
	// Now you need to construct the cart object with the accumulated cartItems
	newCart := &model.Cart{
		// Set the appropriate values for Total, User, and Active
		Total:  resp.Total,       // Replace with the actual total
		User:   int(resp.UserID), // Replace with the actual user ID
		Active: true,             // Replace with the actual active status
		Items:  modelCartItems,
	}

	return newCart, nil
}

// RemoveAllCart is the resolver for the removeAllCart field.
func (r *mutationResolver) RemoveAllCart(ctx context.Context, cartID int) (*model.Cart, error) {
	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	resp, err := cartHandler.RemoveAllCart(ctx, uint32(cartID))
	if err != nil {
		return nil, err
	}
	idString := strconv.FormatUint(uint64(resp.ID), 10)
	deletedCart := &model.Cart{
		ID:     &idString,
		Active: resp.Active,
	}
	return deletedCart, nil
}

// CreateStore is the resolver for the createStore field.
func (r *mutationResolver) CreateStore(ctx context.Context, input model.StoreInput) (*model.Store, error) {
	panic(fmt.Errorf("not implemented: CreateStore - createStore"))
}

// UpdateStore is the resolver for the updateStore field.
func (r *mutationResolver) UpdateStore(ctx context.Context, storeID int) (*model.Store, error) {
	panic(fmt.Errorf("not implemented: UpdateStore - updateStore"))
}

// DeleteStore is the resolver for the deleteStore field.
func (r *mutationResolver) DeleteStore(ctx context.Context, storeID int) (*model.Store, error) {
	panic(fmt.Errorf("not implemented: DeleteStore - deleteStore"))
}

// InitializePayment is the resolver for the initializePayment field.
func (r *mutationResolver) InitializePayment(ctx context.Context, input model.PaymentData) (*string, error) {
	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	paymentOrder := &store.Order{
		Fee:            10.56,
		UserID:         input.UserID,
		PaymentGateway: input.PaymentGateway,
	}
	resp, err := cartHandler.InitiatePayment(ctx, paymentOrder)
	if err != nil {
		return nil, err
	}
	return &resp, err
}

// Users is the resolver for the Users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	resp, err := userHandler.GetUsers(ctx)
	if err != nil {
		return nil, err
	}

	var users []*model.User

	// Assuming resp is a slice of users
	for _, item := range resp {
		accessToken := item.AccessToken
		refreshToken := item.RefreshToken

		user := &model.User{
			ID:           strconv.FormatInt(int64(item.ID), 10),
			Fullname:     item.Fullname,
			Campus:       item.Campus,
			Email:        item.Email,
			Phone:        item.Phone,
			Twofa:        item.Twofa,
			Active:       item.Active,
			AccessToken:  &accessToken,
			RefreshToken: &refreshToken,
			Usertype:     item.Usertype,
			Code:         item.Code,
			// Codeexpiry: item.Codeexpiry.Format(time.RFC3339),
			Password: "lol......what do y'need it for?",
		}

		for _, store := range item.Stores {
			stores := &model.Store{
				ID:          strconv.FormatInt(int64(store.ID), 10),
				Name:        store.Name,
				Description: store.Description,
				Link:        store.Link,
				User:        int(store.UserID),
				// Products: store.Products,
				// Followers: store.Followers,
				HasPhysicalAddress: store.HasPhysicalAddress,
			}
			user.Stores = append(user.Stores, stores)
		}
		users = append(users, user)
	}

	return users, nil
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	resp, err := userHandler.GetUser(ctx, id)
	if err != nil {
		return nil, err
	}
	accessToken := resp.AccessToken
	refreshToken := resp.RefreshToken

	user := &model.User{
		ID:           strconv.FormatInt(int64(resp.ID), 10),
		Fullname:     resp.Fullname,
		Campus:       resp.Campus,
		Email:        resp.Email,
		Phone:        resp.Phone,
		Twofa:        resp.Twofa,
		Active:       resp.Active,
		AccessToken:  &accessToken,
		RefreshToken: &refreshToken,
		Usertype:     resp.Usertype,
		Code:         resp.Code,
		// Stores: resp.Stores,
		// Codeexpiry: resp.Codeexpiry.Format(time.RFC3339),
		Password: "lol......what do y'need it for?",
	}
	for _, store := range resp.Stores {
		stores := &model.Store{
			ID:          strconv.FormatInt(int64(store.ID), 10),
			Name:        store.Name,
			Description: store.Name,
			Link:        store.Link,
			User:        int(store.UserID),
			// Products: store.Products,
			// Followers: store.Followers,
			HasPhysicalAddress: store.HasPhysicalAddress,
		}
		user.Stores = append(user.Stores, stores)
	}
	return user, nil
}

// Categories is the resolver for the Categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetCategories(ctx)
	if err != nil {
		return nil, err
	}

	var categories []*model.Category

	// Assuming resp is a slice of categories
	for _, item := range resp {
		var subCategories []*model.SubCategory

		for _, subItem := range item.SubCategories {
			subCategory := &model.SubCategory{
				Name:     subItem.Name,
				Slug:     subItem.Slug,
				Category: int(subItem.CategoryID),
			}
			subCategories = append(subCategories, subCategory)
		}

		category := &model.Category{
			Name:          item.Name,
			Slug:          item.Slug,
			Subcategories: subCategories,
			ID:            strconv.Itoa(item.ID),
		}
		categories = append(categories, category)
	}
	return categories, nil
}

// Category is the resolver for the Category field.
func (r *queryResolver) Category(ctx context.Context, id int) (*model.Category, error) {
	panic(fmt.Errorf("not implemented: Category - Category"))
}

// SubCategory is the resolver for the SubCategory field.
func (r *queryResolver) SubCategory(ctx context.Context, id string) (*model.SubCategory, error) {
	panic(fmt.Errorf("not implemented: SubCategory - SubCategory"))
}

// Products is the resolver for the Products field.
func (r *queryResolver) Products(ctx context.Context, store *string, limit *int, offset *int) (*model.ProductPaginationData, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)

	resp, err := productHandler.GetProducts(ctx, *store, *limit, *offset)
	if err != nil {
		return nil, err
	}

	var products []*model.Product

	// Assuming resp is a slice of products
	for _, item := range resp {
		product := &model.Product{
			// ID:       strconv.FormatInt(int64(item.ID), 10),
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Images,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			Store:       item.Store,
			Category:    item.Category,
			Subcategory: item.Subcategory,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			product.Variant = append(product.Variant, productVariant)
		
		}
		}
		products = append(products, product)
	}
	payload := &model.ProductPaginationData{
		Data:        products,
		CurrentPage: *offset + 1,
		PerPage:     *limit,
		Total:       100,
	}

	return payload, nil
}

// Product is the resolver for the Product field.
func (r *queryResolver) Product(ctx context.Context, id int) (*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetProduct(ctx, uint32(id))
	if err != nil {
		return nil, err
	}

	product := &model.Product{
		// ID:       strconv.FormatInt(int64(resp.ID), 10),
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Images,
		Price:       resp.Price,
		Status:      resp.Status,
		Quantity:    resp.Quantity,
		Slug:        resp.Slug,
		Store:       resp.Store,
		Category:    resp.Category,
		Subcategory: resp.Subcategory,
	}
	if len(resp.Variant) != 0 {
			for _, outerItem := range resp.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			product.Variant = append(product.Variant, productVariant)
		
		}
		}
	return product, nil
}

// WishListedProducts is the resolver for the WishListedProducts field.
func (r *queryResolver) WishListedProducts(ctx context.Context, user int) ([]*model.WishList, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetWishListedProducts(ctx, uint32(user))
	if err != nil {
		return nil, err
	}
	wishlists := []*model.WishList{}
	for i, item := range resp {
		wishlist := &model.WishList{
			ProductID:        int(item.Product.ID),
			ProductName:      &item.Product.Name,
			ProductDiscount:  &item.Product.Discount,
			ProductPrice:     &item.Product.Price,
			ProductThumbnail: &item.Product.Thumbnail,
			ProductQuantity:  &item.Product.Quantity,
			ProductStatus:    &item.Product.Status,
			UserID:           int(resp[i].UserID),
		}
		wishlists = append(wishlists, wishlist)
	}
	return wishlists, nil
}

// RecommendedProducts is the resolver for the RecommendedProducts field.
func (r *queryResolver) RecommendedProducts(ctx context.Context, query string) ([]*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetRecommendedProducts(ctx, query)
	if err != nil {
		return nil, err
	}
	var products []*model.Product

	for _, item := range resp {
		product := &model.Product{
			// ID:       strconv.FormatInt(int64(item.ID), 10),
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Images,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			// Variant:     item.Variant,
			Store:       item.Store,
			Category:    item.Category,
			Subcategory: item.Subcategory,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			product.Variant = append(product.Variant, productVariant)
		
		}
		}
		products = append(products, product)
	}
	return products, nil
}

// Cart is the resolver for the Cart field.
func (r *queryResolver) Cart(ctx context.Context, user int) (*model.Cart, error) {
	// token:= ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEiLCJmdWxsbmFtZSI6IkFsdWtvIEl5dW5hZGUiLCJjYW1wdXMiOiIiLCJwaG9uZSI6IjAwMCIsInVzZXJ0eXBlIjoic2VsbGVyIiwic3RvcmVzIjpudWxsLCJpc3MiOiIxIiwiZXhwIjoxNjk3MzA4MDUwfQ.7Q3jB-cekMiZZekcEIP_HO2itIymY8YqeQ4vk-4m1CY")
	if authErr != nil {
		return nil, authErr
	}
	cartRep := app.InitializePackage(app.CartPackage)
	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		panic("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	resp, err := cartHandler.GetCart(ctx, uint32(user))
	if err != nil {
		return nil, err
	}
	var modelCartItems []*model.CartItem

	for _, item := range resp.Items {
		modelProduct := &model.Product{
			ID:          int(item.Product.ID),
			Quantity:    item.Product.Quantity,
			Name:        item.Product.Name,
			Description: item.Product.Description,
			Price:       item.Product.Price,
			Thumbnail:   item.Product.Thumbnail,
			Image:       item.Product.Images,
			Discount:    item.Product.Discount,
			Category:    item.Product.Category,
			Status:      item.Product.Status,
			Store:       item.Product.Store,
		}
		if len(item.Product.Variant) != 0 {
			for _, outerItem := range item.Product.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			modelProduct.Variant = append(modelProduct.Variant, productVariant)
		
		}
		}
		modelItem := &model.CartItem{
			Product:  modelProduct,
			Quantity: int(item.Quantity),
		}
		modelCartItems = append(modelCartItems, modelItem)
	}
	// var items []*model.CartItem
	cart := &model.Cart{
		Total: resp.Total,
		Items: modelCartItems,
	}
	return cart, nil
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, query string) ([]*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.SearchProducts(ctx, query)
	if err != nil {
		return nil, err
	}
	var products []*model.Product

	for _, item := range resp {
		product := &model.Product{
			// ID:       strconv.FormatInt(int64(item.ID), 10),
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Images,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			Store:       item.Store,
			Category:    item.Category,
			Subcategory: item.Subcategory,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			product.Variant = append(product.Variant, productVariant)
		
		}
		}
		products = append(products, product)
	}
	return products, nil
}

// Stores is the resolver for the Stores field.
func (r *queryResolver) Stores(ctx context.Context, user *int, limit *int, offset *int) (*model.StorePaginationData, error) {
	panic(fmt.Errorf("not implemented: Stores - Stores"))
}

// Store is the resolver for the Store field.
func (r *queryResolver) Store(ctx context.Context, id int) (*model.Store, error) {
	panic(fmt.Errorf("not implemented: Store - Store"))
}

// ProductSearchResults is the resolver for the productSearchResults field.
func (r *subscriptionResolver) ProductSearchResults(ctx context.Context, query string) (<-chan []*model.Product, error) {
	panic(fmt.Errorf("not implemented: ProductSearchResults - productSearchResults"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
