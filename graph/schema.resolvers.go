package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/Chrisentech/aluta-market-api/graph/model"
	"github.com/Chrisentech/aluta-market-api/internals/cart"
	"github.com/Chrisentech/aluta-market-api/internals/messages"
	"github.com/Chrisentech/aluta-market-api/internals/product"
	"github.com/Chrisentech/aluta-market-api/internals/store"
	"github.com/Chrisentech/aluta-market-api/internals/user"
	"github.com/Chrisentech/aluta-market-api/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	// Convert GraphQL input to user service input
	defaultDob := time.Now().Format("2006-01-02")
	defaultGender := "unspecified"
	createUserReq := &user.CreateUserReq{
		Fullname:           input.Fullname,
		Email:              input.Email,
		Password:           input.Password,
		Phone:              input.Phone,
		Campus:             input.Campus,
		Usertype:           input.Usertype,
		Active:             false,
		Twofa:              false,
		StoreName:          "",
		StoreEmail:         "",
		HasPhysicalAddress: false,
		UUID:               utils.GenerateUUID(),
		Avatar:             "https://icon-library.com/images/anonymous-avatar-icon/anonymous-avatar-icon-25.jpg",
		Dob:                &defaultDob,
		Gender:             defaultGender,
		Online:             false,
		FollowedStores:     []string{},
		PaymentDetails: user.PaymentDetails{
			Name:    "",
			Phone:   "",
			Address: "",
			Info:    "",
		},
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Handle store details if provided and usertype is seller
	if input.Stores != nil && input.Usertype == "seller" {
		createUserReq.StoreName = input.Stores.Name
		createUserReq.StoreEmail = input.Email
		createUserReq.StorePhone = input.Stores.Phone
		createUserReq.StoreLink = input.Stores.Link
		createUserReq.Description = input.Stores.Description
		createUserReq.StoreAddress = input.Stores.Address
		createUserReq.HasPhysicalAddress = input.Stores.HasPhysicalAddress
	}

	// Add detailed request logging
	fmt.Printf("Creating user with request: %+v\n", createUserReq)

	// Call the user handler to create user
	result, err := r.UserHandler.CreateUser(ctx, createUserReq)
	if err != nil {
		fmt.Printf("CreateUser detailed error: %+v\n", err)
		fmt.Printf("CreateUser error type: %T\n", err)
		return nil, fmt.Errorf("failed to create user: %v", err)
	}

	// Type assert the Data interface{} to User struct
	userData, ok := result.Data.(*user.User)
	if !ok {
		return nil, fmt.Errorf("invalid user data format")
	}

	// Set default values for required fields if they're nil
	active := true
	if userData.Active != nil {
		active = *userData.Active
	}

	// Convert user service response to GraphQL model
	userResponse := &model.User{
		ID:           strconv.FormatInt(int64(userData.ID), 10),
		Fullname:     userData.Fullname,
		Email:        userData.Email,
		Phone:        userData.Phone,
		Campus:       userData.Campus,
		Usertype:     userData.Usertype,
		Active:       active,
		AccessToken:  &userData.AccessToken,
		RefreshToken: &userData.RefreshToken,
	}

	// If user is a seller, fetch their store
	if userData.Usertype == "seller" {
		storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
		userStore, err := storeHandler.GetStore(ctx, userData.ID)
		if err == nil && userStore != nil {
			userResponse.Stores = []*model.Store{{
				ID:                 strconv.Itoa(int(userStore.ID)),
				Name:               userStore.Name,
				Link:               userStore.Link,
				Description:        userStore.Description,
				Address:            userStore.Address,
				Phone:              userStore.Phone,
				HasPhysicalAddress: userStore.HasPhysicalAddress,
				Thumbnail:          userStore.Thumbnail,
				Background:         userStore.Background,
				Status:             userStore.Status,
				User:               int(userStore.UserID),
			}}

			// Create DVA account
			dvaDetails := &user.DVADetails{
				User:      *userData,
				StoreName: createUserReq.StoreName,
			}

			_, err := r.UserHandler.CreateDVAAccount(ctx, dvaDetails)
			if err != nil {
				log.Printf("Warning: Failed to create DVA account: %v", err)
			}
		}
	}
	return userResponse, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.StoreOrderInput) (*model.StoreOrder, error) {
	panic(fmt.Errorf("not implemented: CreateOrder - createOrder"))
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, input model.UpdateStoreOrderInput) (*model.StoreOrder, error) {
	panic(fmt.Errorf("not implemented: UpdateOrder - updateOrder"))
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input *model.UpdateUserInput) (*model.User, error) {
	// Check if ID is provided
	if input.ID == nil {
		return nil, fmt.Errorf("user ID is required")
	}

	// Convert string ID to uint32
	userID, err := strconv.ParseUint(*input.ID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %v", err)
	}

	// Create update request
	updateReq := &user.UpdateUserReq{
		ID: uint32(userID),
	}

	// Handle optional fields
	if input.Fullname != nil {
		updateReq.Fullname = *input.Fullname
	}
	if input.Email != nil {
		updateReq.Email = *input.Email
	}
	if input.Campus != nil {
		updateReq.Campus = *input.Campus
	}
	if input.Phone != nil {
		updateReq.Phone = *input.Phone
	}
	if input.Avatar != nil {
		updateReq.Avatar = *input.Avatar
	}
	if input.Dob != nil {
		updateReq.Dob = *input.Dob
	}
	// Add store-related fields
	if input.StoreName != nil {
		updateReq.StoreName = *input.StoreName
	}
	if input.StoreEmail != nil {
		updateReq.StoreEmail = *input.StoreEmail
	}
	if input.HasPhysicalAddress != nil {
		updateReq.HasPhysicalAddress = *input.HasPhysicalAddress
	}

	if input.PaymentDetails != nil {
		updateReq.PaymentDetails = user.PaymentDetails{
			Name:    input.PaymentDetails.Name,
			Phone:   input.PaymentDetails.Phone,
			Address: input.PaymentDetails.Address,
			Info:    input.PaymentDetails.Info,
		}
	}

	// Call the user handler to update user
	result, err := r.UserHandler.UpdateUser(ctx, updateReq)
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}

	// Convert user service response to GraphQL model
	userResponse := &model.User{
		ID:           strconv.FormatInt(int64(result.ID), 10),
		UUID:         result.UUID,
		Fullname:     result.Fullname,
		Email:        result.Email,
		Phone:        result.Phone,
		Campus:       result.Campus,
		Usertype:     result.Usertype,
		Active:       *result.Active,
		AccessToken:  &result.AccessToken,
		RefreshToken: &result.RefreshToken,
		Online:       result.Online,
	}

	// If user is a seller, create and fetch their store
	if result.Usertype == "seller" && input.Stores != nil {
		storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

		// Create store with input details
		storeInput := &store.Store{
			Name:               input.Stores.Name,
			Link:               input.Stores.Link,
			UserID:             result.ID,
			Description:        input.Stores.Description,
			Address:            input.Stores.Address,
			Phone:              input.Stores.Phone,
			HasPhysicalAddress: input.Stores.HasPhysicalAddress,
			Email:              result.Email,
			Status:             true,
		}

		createdStore, err := storeHandler.CreateStore(ctx, storeInput)
		if err == nil && createdStore != nil {
			userResponse.Stores = []*model.Store{{
				ID:                 strconv.Itoa(int(createdStore.ID)),
				Name:               createdStore.Name,
				Link:               createdStore.Link,
				Description:        createdStore.Description,
				Address:            createdStore.Address,
				Phone:              createdStore.Phone,
				HasPhysicalAddress: createdStore.HasPhysicalAddress,
				Thumbnail:          createdStore.Thumbnail,
				Background:         createdStore.Background,
				Status:             createdStore.Status,
				User:               int(createdStore.UserID),
			}}
		}
	}

	return userResponse, nil
}

// CreateVerifyOtp is the resolver for the createVerifyOTP field.
func (r *mutationResolver) CreateVerifyOtp(ctx context.Context, input model.NewVerifyOtp) (*model.LoginRes, error) {
	// Create verification request
	verifyReq := &user.VerifyOTPReq{
		Code:     input.Code,
		Phone:    input.Phone,
		Attempts: input.Attempts,
	}

	// Handle optional email field
	if input.Email != nil {
		verifyReq.Email = *input.Email
	}

	// Call user handler to verify OTP
	result, err := r.UserHandler.VerifyOTP(ctx, verifyReq)
	if err != nil {
		return nil, fmt.Errorf("OTP verification failed: %v", err)
	}

	// Convert response to GraphQL model
	return &model.LoginRes{
		ID:           int(result.ID),
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginReq) (*model.LoginRes, error) {
	loginReq := &user.LoginUserReq{
		Email:    input.Email,
		Password: input.Password,
	}

	result, err := r.UserHandler.Login(ctx, loginReq)
	if err != nil {
		return nil, err
	}

	return &model.LoginRes{
		ID:           int(result.ID),
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// AddHandledProduct is the resolver for the addHandledProduct field.
func (r *mutationResolver) AddHandledProduct(ctx context.Context, userID int, productID int, typeArg string) (*model.HandledProducts, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert int to uint32 for the handler
	userIDUint := uint32(userID)
	productIDUint := uint32(productID)

	// First, check if the product exists in handled products
	products, err := productHandler.GetHandledProducts(ctx, userIDUint, typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing products: %v", err)
	}

	// Check if product already exists
	for _, p := range products {
		if p.Product != nil && p.Product.ID == productIDUint {
			// Return the existing product instead of error
			status := p.Product.Status
			price := p.Product.Price
			discount := p.Product.Discount
			quantity := p.Product.Quantity
			name := p.Product.Name
			thumbnail := p.Product.Thumbnail

			return &model.HandledProducts{
				UserID:           int(p.UserID),
				ProductID:        int(p.Product.ID),
				ProductName:      &name,
				ProductThumbnail: &thumbnail,
				ProductPrice:     &price,
				ProductDiscount:  &discount,
				ProductStatus:    &status,
				ProductQuantity:  &quantity,
			}, nil
		}
	}

	// If product doesn't exist, add it
	result, err := productHandler.AddHandledProduct(ctx, userIDUint, productIDUint, typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to add handled product: %v", err)
	}

	// Convert to GraphQL model
	status := result.Product.Status
	price := result.Product.Price
	discount := result.Product.Discount
	quantity := result.Product.Quantity
	name := result.Product.Name
	thumbnail := result.Product.Thumbnail

	return &model.HandledProducts{
		UserID:           int(result.UserID),
		ProductID:        int(result.Product.ID),
		ProductName:      &name,
		ProductThumbnail: &thumbnail,
		ProductPrice:     &price,
		ProductDiscount:  &discount,
		ProductStatus:    &status,
		ProductQuantity:  &quantity,
	}, nil
}

// AddReview is the resolver for the addReview field.
func (r *mutationResolver) AddReview(ctx context.Context, input model.ReviewInput) (*model.Review, error) {
	panic(fmt.Errorf("not implemented: AddReview - addReview"))
}

// CheckStoreName is the resolver for the checkStoreName field.
func (r *mutationResolver) CheckStoreName(ctx context.Context, input string) (*string, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	err := storeHandler.CheckStoreName(ctx, input)
	if err != nil {
		return nil, err
	}

	// If no error, return the store name as available
	result := "Store name available"
	return &result, nil
}

// UpdateStoreFollower is the resolver for the updateStoreFollower field.
func (r *mutationResolver) UpdateStoreFollower(ctx context.Context, input *model.StoreFollowerInput) (*model.Store, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Convert input to store follower type
	follower := &store.Follower{
		FollowerID:    uint32(input.FollowerID),
		FollowerName:  input.FollowerName,
		FollowerImage: input.FollowerImage,
		StoreID:       uint32(input.StoreID),
	}

	// Update store follower - using the correct method name
	updatedStore, err := storeHandler.UpdateStoreFollowership(ctx, follower.StoreID, follower, "follow")
	if err != nil {
		return nil, fmt.Errorf("failed to update store follower: %v", err)
	}

	// Convert followers to GraphQL model
	var followers []*model.StoreFollower
	for _, f := range updatedStore.Followers {
		followers = append(followers, &model.StoreFollower{
			FollowerID:    int(f.FollowerID),
			FollowerName:  f.FollowerName,
			StoreID:       int(f.StoreID),
			FollowerImage: f.FollowerImage,
		})
	}

	// Convert products to GraphQL model
	var products []*model.Product
	for _, p := range updatedStore.Products {
		products = append(products, &model.Product{
			ID:          int(p.ID),
			Name:        p.Name,
			Price:       p.Price,
			Description: p.Description,
			Discount:    p.Discount,
			Image:       p.Images,
			Slug:        p.Slug,
			Quantity:    p.Quantity,
			Status:      p.Status,
			Thumbnail:   p.Thumbnail,
			Store:       p.Store,
			Category:    p.Category,
			Subcategory: p.Subcategory,
		})
	}

	return &model.Store{
		ID:                 strconv.Itoa(int(updatedStore.ID)),
		Link:               updatedStore.Link,
		Name:               updatedStore.Name,
		User:               int(updatedStore.UserID),
		Description:        updatedStore.Description,
		Thumbnail:          updatedStore.Thumbnail,
		Phone:              updatedStore.Phone,
		Background:         updatedStore.Background,
		Address:            updatedStore.Address,
		Status:             updatedStore.Status,
		HasPhysicalAddress: updatedStore.HasPhysicalAddress,
		Wallet:             float64(updatedStore.Wallet),
		Visitors:           updatedStore.Visitors,
		Followers:          followers,
		Product:            products,
	}, nil
}

// CreateSkynet is the resolver for the createSkynet field.
func (r *mutationResolver) CreateSkynet(ctx context.Context, input *model.SkynetInput) (string, error) {
	panic(fmt.Errorf("not implemented: CreateSkynet - createSkynet"))
}

// RemoveHandledProduct is the resolver for the removeHandledProduct field.
func (r *mutationResolver) RemoveHandledProduct(ctx context.Context, prd int, typeArg *string) (*model.HandledProducts, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert int to uint32
	productID := uint32(prd)

	// Get the product details before removal
	products, err := productHandler.GetHandledProducts(ctx, 0, *typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to get handled products: %v", err)
	}

	// Find the specific product
	var targetProduct *product.HandledProduct
	for _, p := range products {
		if p.ProductID == productID {
			targetProduct = p
			break
		}
	}

	if targetProduct == nil {
		return nil, fmt.Errorf("product not found in handled products")
	}

	// Remove the handled product
	err = productHandler.RemoveHandledProduct(ctx, productID, *typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to remove handled product: %v", err)
	}

	// Get the product details to return in response
	productDetails, err := productHandler.GetProduct(ctx, productID, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to get product details: %v", err)
	}

	// Prepare the response
	status := productDetails.Status
	price := productDetails.Price
	discount := productDetails.Discount
	quantity := productDetails.Quantity
	name := productDetails.Name
	thumbnail := productDetails.Thumbnail

	return &model.HandledProducts{
		UserID:           int(targetProduct.UserID),
		ProductID:        int(productDetails.ID),
		ProductName:      &name,
		ProductThumbnail: &thumbnail,
		ProductPrice:     &price,
		ProductDiscount:  &discount,
		ProductStatus:    &status,
		ProductQuantity:  &quantity,
	}, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.NewCategory) (*model.Category, error) {
	panic(fmt.Errorf("not implemented: CreateCategory - createCategory"))
}

// CreateSubCategory is the resolver for the createSubCategory field.
func (r *mutationResolver) CreateSubCategory(ctx context.Context, input model.NewSubCategory) (*model.SubCategory, error) {
	panic(fmt.Errorf("not implemented: CreateSubCategory - createSubCategory"))
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	// Add debug logging
	fmt.Printf("Creating product with category ID: %d, subcategory: %s\n", input.Category, input.Subcategory)
	// Convert input to internal product structure
	newProduct := &product.NewProduct{
		Name:            input.Name,
		Description:     input.Description,
		Images:          input.Image,
		Thumbnail:       input.Thumbnail,
		Price:           input.Price,
		Discount:        input.Discount,
		Status:          &input.Status,
		Quantity:        input.Quantity,
		File:            input.File,
		Store:           input.Store,
		CategoryID:      uint8(input.Category),
		SubCategoryName: input.Subcategory,
		AlwaysAvailbale: input.AlwaysAvailable,
	}

	// Handle variant conversion if present
	if input.Variant != nil {
		variants := make([]*product.VariantType, 0)
		for _, v := range input.Variant {
			variant := &product.VariantType{
				Name:  v.Name,
				Value: make([]*product.VariantValue, 0),
			}
			for _, val := range v.Value {
				if val.Price != nil {
					variant.Value = append(variant.Value, &product.VariantValue{
						Value:  val.Value,
						Price:  *val.Price, // Dereference the pointer
						Images: val.Images,
					})
				}
			}
			variants = append(variants, variant)
		}
		newProduct.Variant = variants
	}

	// Log the category lookup
	fmt.Printf("Looking up category and subcategory: %+v\n", newProduct)

	// Create product
	createdProduct, err := r.ProductHandler.CreateProduct(ctx, newProduct)
	if err != nil {
		fmt.Printf("Error creating product: %v\n", err)
		return nil, fmt.Errorf("failed to create product: %v", err)
	}

	// Convert to GraphQL model
	return &model.Product{
		ID:              int(createdProduct.ID),
		Name:            createdProduct.Name,
		Description:     createdProduct.Description,
		Price:           createdProduct.Price,
		Discount:        createdProduct.Discount,
		Status:          createdProduct.Status,
		Quantity:        createdProduct.Quantity,
		Thumbnail:       createdProduct.Thumbnail,
		Image:           createdProduct.Images,
		File:            &createdProduct.File,
		Store:           createdProduct.Store,
		Category:        createdProduct.Category,
		Subcategory:     createdProduct.Subcategory,
		AlwaysAvailable: createdProduct.AlwaysAvailbale,
	}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input *model.UpdateProductInput) (*model.Product, error) {
	// Convert the input ID to uint32
	productID := input.ID

	// Create NewProduct struct with the update data
	updateData := &product.NewProduct{
		ID:     productID,
		Status: input.Status,
	}

	// Call the product handler to update the product
	updatedProduct, err := r.ProductHandler.UpdateProduct(ctx, updateData)
	if err != nil {
		return nil, fmt.Errorf("failed to update product: %v", err)
	}

	// Convert the updated product to the GraphQL model type
	return &model.Product{
		ID:              int(updatedProduct.ID),
		Name:            updatedProduct.Name,
		Slug:            updatedProduct.Slug,
		Description:     updatedProduct.Description,
		Price:           updatedProduct.Price,
		Discount:        updatedProduct.Discount,
		Status:          updatedProduct.Status,
		Quantity:        updatedProduct.Quantity,
		Thumbnail:       updatedProduct.Thumbnail,
		Image:           updatedProduct.Images,
		File:            &updatedProduct.File,
		Store:           updatedProduct.Store,
		Category:        updatedProduct.Category,
		Subcategory:     updatedProduct.Subcategory,
		AlwaysAvailable: updatedProduct.AlwaysAvailbale,
		Type:            updatedProduct.Type,
	}, nil
}

// ToggleStoreFollowStatus is the resolver for the toggleStoreFollowStatus field.
func (r *mutationResolver) ToggleStoreFollowStatus(ctx context.Context, user int, store int) (*string, error) {
	panic(fmt.Errorf("not implemented: ToggleStoreFollowStatus - toggleStoreFollowStatus"))
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, productID int) (*model.Product, error) {
	// Get product before deletion to return its data
	product, err := r.ProductHandler.GetProduct(ctx, uint32(productID), 0)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product: %v", err)
	}

	// Delete the product
	err = r.ProductHandler.DeleteProduct(ctx, uint32(productID))
	if err != nil {
		return nil, fmt.Errorf("failed to delete product: %v", err)
	}

	// Return the deleted product data
	return &model.Product{
		ID:              int(product.ID),
		Name:            product.Name,
		Slug:            product.Slug,
		Description:     product.Description,
		Price:           product.Price,
		Discount:        product.Discount,
		Status:          product.Status,
		Quantity:        product.Quantity,
		Thumbnail:       product.Thumbnail,
		Image:           product.Images,
		File:            &product.File,
		Store:           product.Store,
		Category:        product.Category,
		Subcategory:     product.Subcategory,
		AlwaysAvailable: product.AlwaysAvailbale,
		Type:            product.Type,
	}, nil
}

// ModifyCart is the resolver for the modifyCart field.
func (r *mutationResolver) ModifyCart(ctx context.Context, input model.ModifyCartItemInput) (*model.Cart, error) {
	cartHandler := cart.NewHandler(cart.NewService(cart.NewRepository()))

	// Create cart item
	cartItem := &cart.CartItems{
		Product: &product.Product{
			ID: 0,
		},
		Quantity: input.Quantity,
	}

	// Set product ID if provided
	if input.ProductID != nil {
		id, err := strconv.ParseUint(*input.ProductID, 10, 32)
		if err != nil {
			return nil, fmt.Errorf("invalid product ID: %v", err)
		}
		cartItem.Product.ID = uint32(id)
	}

	// Set product name if provided
	if input.ProductName != nil {
		cartItem.Product.Name = *input.ProductName
	}

	// Modify cart
	result, err := cartHandler.ModifyCart(ctx, cartItem, uint32(input.User))
	if err != nil {
		return nil, fmt.Errorf("failed to modify cart: %v", err)
	}

	// Convert cart items to GraphQL model
	var cartItems []*model.CartItem
	for _, item := range result.Items {
		cartItem := &model.CartItem{
			Product: &model.Product{
				ID:        int(item.Product.ID),
				Name:      item.Product.Name,
				Price:     item.Product.Price,
				Discount:  item.Product.Discount,
				Quantity:  item.Product.Quantity,
				Thumbnail: item.Product.Thumbnail,
				Image:     item.Product.Images,
				Store:     item.Product.Store,
			},
			Quantity: item.Quantity,
		}
		cartItems = append(cartItems, cartItem)
	}

	// Convert ID to string
	id := strconv.FormatUint(uint64(result.ID), 10)

	return &model.Cart{
		Items:  cartItems,
		Total:  result.Total,
		Active: result.Active,
		User:   int(result.UserID),
		ID:     &id,
	}, nil
}

// RemoveAllCart is the resolver for the removeAllCart field.
func (r *mutationResolver) RemoveAllCart(ctx context.Context, cartID int) (*model.Cart, error) {
	cartHandler := cart.NewHandler(cart.NewService(cart.NewRepository()))

	// Convert int to uint32 for the handler
	cartIDUint := uint32(cartID)

	// Get cart before removing
	result, err := cartHandler.GetCart(ctx, cartIDUint)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch cart: %v", err)
	}

	// Remove all items from cart
	err = cartHandler.RemoveAllCart(ctx, cartIDUint)
	if err != nil {
		return nil, fmt.Errorf("failed to remove cart: %v", err)
	}

	// Convert cart items to GraphQL model
	var cartItems []*model.CartItem
	for _, item := range result.Items {
		cartItem := &model.CartItem{
			Product: &model.Product{
				ID:        int(item.Product.ID),
				Name:      item.Product.Name,
				Price:     item.Product.Price,
				Discount:  item.Product.Discount,
				Quantity:  item.Product.Quantity,
				Thumbnail: item.Product.Thumbnail,
				Image:     item.Product.Images,
				Store:     item.Product.Store,
			},
			Quantity: item.Quantity,
		}
		cartItems = append(cartItems, cartItem)
	}

	// Convert ID to string
	id := strconv.FormatUint(uint64(result.ID), 10)

	return &model.Cart{
		Items:  cartItems,
		Total:  result.Total,
		Active: false, // Cart is now inactive
		User:   int(result.UserID),
		ID:     &id,
	}, nil
}

// CreateStore is the resolver for the createStore field.
func (r *mutationResolver) CreateStore(ctx context.Context, input model.StoreInput) (*model.Store, error) {
	// Handle optional fields
	email := ""
	if input.Email != nil {
		email = *input.Email
	}

	thumbnail := ""
	if input.Thumbnail != nil {
		thumbnail = *input.Thumbnail
	}

	background := ""
	if input.Background != nil {
		background = *input.Background
	}

	// Convert input to store.Store
	storeInput := &store.Store{
		Name:               input.Name,
		Link:               input.Link,
		UserID:             uint32(input.User),
		Description:        input.Description,
		Address:            input.Address,
		Phone:              input.Phone,
		HasPhysicalAddress: input.HasPhysicalAddress,
		Email:              email,
		Thumbnail:          thumbnail,
		Background:         background,
		Status:             input.Status,
	}

	// Call the store handler
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
	createdStore, err := storeHandler.CreateStore(ctx, storeInput)
	if err != nil {
		return nil, fmt.Errorf("failed to create store: %v", err)
	}

	// Convert store.Store to model.Store
	return &model.Store{
		ID:                 strconv.Itoa(int(createdStore.ID)),
		Name:               createdStore.Name,
		Link:               createdStore.Link,
		User:               int(createdStore.UserID),
		Description:        createdStore.Description,
		Address:            createdStore.Address,
		Phone:              createdStore.Phone,
		HasPhysicalAddress: createdStore.HasPhysicalAddress,
		Email:              createdStore.Email,
		Thumbnail:          createdStore.Thumbnail,
		Background:         createdStore.Background,
		Status:             createdStore.Status,
		Wallet:             createdStore.Wallet,
	}, nil
}

// UpdateStore is the resolver for the updateStore field.
func (r *mutationResolver) UpdateStore(ctx context.Context, input *model.UpdateStoreInput) (*model.Store, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Convert *string ID to uint32
	if input.ID == nil {
		return nil, fmt.Errorf("store ID is required")
	}
	storeID, err := strconv.ParseUint(*input.ID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid store ID: %v", err)
	}

	// Create store update input
	storeInput := &store.UpdateStore{
		ID: uint32(storeID),
	}

	// Handle thumbnail update if provided
	if input.Thumbnail != nil {
		storeInput.Thumbnail = *input.Thumbnail
	}

	// Handle visitor update if provided
	if input.Visitor != nil {
		storeInput.Visitors = *input.Visitor
	}

	// Update store
	updatedStore, err := storeHandler.UpdateStore(ctx, storeInput)
	if err != nil {
		return nil, fmt.Errorf("failed to update store: %v", err)
	}

	// Convert followers to GraphQL model
	var followers []*model.StoreFollower
	for _, f := range updatedStore.Followers {
		followers = append(followers, &model.StoreFollower{
			FollowerID:    int(f.FollowerID),
			FollowerName:  f.FollowerName,
			StoreID:       int(f.StoreID),
			FollowerImage: f.FollowerImage,
		})
	}

	// Convert products to GraphQL model
	var products []*model.Product
	for _, p := range updatedStore.Products {
		products = append(products, &model.Product{
			ID:          int(p.ID),
			Name:        p.Name,
			Price:       p.Price,
			Description: p.Description,
			Discount:    p.Discount,
			Image:       p.Images,
			Slug:        p.Slug,
			Quantity:    p.Quantity,
			Status:      p.Status,
			Thumbnail:   p.Thumbnail,
			Store:       p.Store,
			Category:    p.Category,
			Subcategory: p.Subcategory,
		})
	}

	return &model.Store{
		ID:                 strconv.Itoa(int(updatedStore.ID)),
		Link:               updatedStore.Link,
		Name:               updatedStore.Name,
		User:               int(updatedStore.UserID),
		Description:        updatedStore.Description,
		Thumbnail:          updatedStore.Thumbnail,
		Phone:              updatedStore.Phone,
		Background:         updatedStore.Background,
		Address:            updatedStore.Address,
		Status:             updatedStore.Status,
		HasPhysicalAddress: updatedStore.HasPhysicalAddress,
		Wallet:             float64(updatedStore.Wallet),
		Visitors:           updatedStore.Visitors,
		Followers:          followers,
		Product:            products,
	}, nil
}

// DeleteStore is the resolver for the deleteStore field.
func (r *mutationResolver) DeleteStore(ctx context.Context, storeID int) (*model.Store, error) {
	panic(fmt.Errorf("not implemented: DeleteStore - deleteStore"))
}

// Update the CreateDVAAccount resolver
func (r *mutationResolver) CreateDVAAccount(ctx context.Context, input model.DVAAccountInput) (string, error) {
	// Get existing user
	existingUser, err := r.UserHandler.GetUser(ctx, input.UserID)
	if err != nil {
		return "", fmt.Errorf("failed to get user details: %v", err)
	}

	// Only proceed if user is a seller
	if existingUser.Usertype != "seller" {
		return "", fmt.Errorf("only sellers can create DVA accounts")
	}

	// Create DVA details
	dvaDetails := &user.DVADetails{
		User:       *existingUser,
		StoreName:  input.StoreName,
		StoreEmail: existingUser.Email,
	}

	// Create DVA account using UserHandler
	accountID, err := r.UserHandler.CreateDVAAccount(ctx, dvaDetails)
	if err != nil {
		return "", fmt.Errorf("failed to create DVA account: %v", err)
	}

	return accountID, nil
}

// InitializePayment is the resolver for the initializePayment field.
func (r *mutationResolver) InitializePayment(ctx context.Context, input model.PaymentData) (*string, error) {
	cartHandler := cart.NewHandler(cart.NewService(cart.NewRepository()))

	// Create order with required fields
	order := store.Order{
		UserID:         input.UserID,
		UUID:           *input.UUID,
		PaymentGateway: *input.PaymentGateway,
		Amount:         *input.Amount,
		Status:         "pending",
		CreatedAt:      time.Now(),
		UpdatedAt:      time.Now(),
	}

	// Initialize payment
	paymentLink, err := cartHandler.IntitiatePayment(ctx, &order)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize payment: %v", err)
	}

	return &paymentLink, nil
}

// VerifySmartCard is the resolver for the verifySmartCard field.
func (r *mutationResolver) VerifySmartCard(ctx context.Context, input model.SmartCardInput) (*model.SmartcardVerificationResponse, error) {
	panic(fmt.Errorf("not implemented: VerifySmartCard - verifySmartCard"))
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, input model.ChatInput) (*model.Chat, error) {
	// Recover from panics
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Recovered from panic in CreateChat: %v", r)
		}
	}()

	// Check if MessageHandler is initialized
	if r.MessageHandler == nil {
		r.MessageHandler = messages.NewMessageHandler(messages.NewService(messages.NewRepository()))
	}

	// Input validation
	if len(input.Users) == 0 {
		return nil, fmt.Errorf("at least one user is required")
	}

	var users []*user.User
	for _, u := range input.Users {
		if u == nil {
			continue
		}

		var avatar string
		if u.Avatar != nil {
			avatar = *u.Avatar
		}

		// Get existing user to preserve their UUID
		existingUser, err := r.UserHandler.GetUser(ctx, strconv.Itoa(u.ID))
		if err != nil {
			return nil, fmt.Errorf("failed to get user data: %v", err)
		}

		users = append(users, &user.User{
			ID:       uint32(u.ID),
			UUID:     existingUser.UUID, // Use existing UUID
			Fullname: u.Fullname,
			Avatar:   avatar,
		})
	}

	// Create chat with basic fields
	chat, err := r.MessageHandler.FindOrCreateChat(ctx, users)
	if err != nil {
		log.Printf("Chat creation error details: %+v", err)
		return nil, fmt.Errorf("failed to create chat: %v", err)
	}

	var messageUsers []*model.User
	for _, u := range users {
		messageUser := &model.User{
			ID:       strconv.Itoa(int(u.ID)),
			UUID:     u.UUID,
			Fullname: u.Fullname,
			Avatar:   &u.Avatar,
		}
		messageUsers = append(messageUsers, messageUser)
	}

	return &model.Chat{
		ID:       strconv.FormatInt(int64(chat.ID), 10),
		Messages: []*model.Message{},
		Users:    messageUsers,
	}, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.MessageInput) (*model.Message, error) {
	// Convert int to string first
	chatIDStr := strconv.Itoa(input.ChatID)
	senderStr := strconv.Itoa(input.Sender)

	chatIDUint, err := strconv.ParseUint(chatIDStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid chat ID: %v", err)
	}

	senderUint, err := strconv.ParseUint(senderStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid sender ID: %v", err)
	}

	msg := &messages.Message{
		ChatID:  uint32(chatIDUint),
		Content: input.Content,
		Sender:  uint32(senderUint),
	}

	if input.Media != nil {
		mediaType := messages.MediaType(*input.Media)
		msg.Media = &mediaType
	}

	err = r.MessageHandler.SendMessage(ctx, msg)
	if err != nil {
		return nil, err
	}

	return &model.Message{
		ID:        strconv.FormatInt(int64(msg.ID), 10),
		ChatID:    strconv.FormatInt(int64(msg.ChatID), 10),
		Content:   msg.Content,
		Sender:    strconv.FormatInt(int64(msg.Sender), 10),
		Media:     (*string)(msg.Media),
		IsRead:    msg.IsRead,
		CreatedAt: msg.CreatedAt.Format(time.RFC3339),
		UpdatedAt: func() *string {
			if !msg.UpdatedAt.IsZero() {
				t := msg.UpdatedAt.Format(time.RFC3339)
				return &t
			}
			return nil
		}(),
	}, nil
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input model.TransactionInput) (*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: CreateTransaction - createTransaction"))
}

// CreateResetPasswordLink is the resolver for the createResetPasswordLink field.
func (r *mutationResolver) CreateResetPasswordLink(ctx context.Context, input model.PasswordResetInput) (bool, error) {
	panic(fmt.Errorf("not implemented: CreateResetPasswordLink - createResetPasswordLink"))
}

// VerifyResetPasswordLink is the resolver for the verifyResetPasswordLink field.
func (r *mutationResolver) VerifyResetPasswordLink(ctx context.Context, input string) (bool, error) {
	panic(fmt.Errorf("not implemented: VerifyResetPasswordLink - verifyResetPasswordLink"))
}

// UpdateUserPassword is the resolver for the updateUserPassword field.
func (r *mutationResolver) UpdateUserPassword(ctx context.Context, input model.PasswordUpdateInput) (bool, error) {
	panic(fmt.Errorf("not implemented: UpdateUserPassword - updateUserPassword"))
}

// WithdrawFund is the resolver for the withdrawFund field.
func (r *mutationResolver) WithdrawFund(ctx context.Context, input model.FundInput) (bool, error) {
	panic(fmt.Errorf("not implemented: WithdrawFund - withdrawFund"))
}

// ConfirmPassword is the resolver for the confirmPassword field.
func (r *mutationResolver) ConfirmPassword(ctx context.Context, input *model.ConfirmPasswordInput) (bool, error) {
	panic(fmt.Errorf("not implemented: ConfirmPassword - confirmPassword"))
}

// CreateInvoice is the resolver for the createInvoice field.
func (r *mutationResolver) CreateInvoice(ctx context.Context, input model.InvoiceInput) (*model.Invoice, error) {
	panic(fmt.Errorf("not implemented: CreateInvoice - createInvoice"))
}

// CreatePaystackAccount is the resolver for the createPaystackAccount field.
func (r *mutationResolver) CreatePaystackAccount(ctx context.Context, email string, bvn string) (*model.PaystackAccount, error) {
	panic(fmt.Errorf("not implemented: CreatePaystackAccount - createPaystackAccount"))
}

// Users is the resolver for the Users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - Users"))
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	result, err := r.UserHandler.GetUser(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %v", err)
	}

	if result == nil {
		return nil, fmt.Errorf("user not found")
	}

	// Convert repository user to GraphQL model with proper type handling
	user := &model.User{
		ID:       strconv.FormatUint(uint64(result.ID), 10),
		UUID:     result.UUID,
		Email:    result.Email,
		Fullname: result.Fullname,
		Phone:    result.Phone,
		Campus:   result.Campus,
		Usertype: result.Usertype,
		Online:   result.Online,
		Active:   *result.Active,
		Twofa:    *result.Twofa,
	}

	// Handle optional string fields
	if result.Avatar != "" {
		user.Avatar = &result.Avatar
	}
	if result.Gender != "" {
		user.Gender = &result.Gender
	}
	if result.Dob != "" {
		user.Dob = &result.Dob
	}

	// Handle tokens
	if result.AccessToken != "" {
		user.AccessToken = &result.AccessToken
	}
	if result.RefreshToken != "" {
		user.RefreshToken = &result.RefreshToken
	}

	// Handle PaymentDetails if they exist
	if result.PaymentDetails.Name != "" {
		user.PaymentDetails = &model.PaymentDetails{
			Name:    result.PaymentDetails.Name,
			Phone:   result.PaymentDetails.Phone,
			Address: result.PaymentDetails.Address,
			Info:    result.PaymentDetails.Info,
		}
	}

	return user, nil
}

// Categories is the resolver for the Categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	categories, err := r.ProductHandler.GetCategories(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch categories: %v", err)
	}

	var result []*model.Category
	for _, cat := range categories {
		// Convert subcategories
		subCategories := make([]*model.SubCategory, 0)
		for _, sub := range cat.SubCategories {
			subCategories = append(subCategories, &model.SubCategory{
				Name:     sub.Name,
				Slug:     sub.Slug,
				Category: int(sub.CategoryID),
			})
		}

		result = append(result, &model.Category{
			ID:            strconv.FormatUint(uint64(cat.ID), 10),
			Name:          cat.Name,
			Slug:          cat.Slug,
			Subcategories: subCategories,
		})
	}
	return result, nil
}

// FollowedStores is the resolver for the FollowedStores field.
func (r *queryResolver) FollowedStores(ctx context.Context, userID int) ([]*model.Store, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Convert int to uint32
	userIDUint := uint32(userID)

	// Get followed stores
	stores, err := storeHandler.GetFollowedStores(ctx, userIDUint)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch followed stores: %v", err)
	}

	// Convert to GraphQL model
	var modelStores []*model.Store
	for _, s := range stores {
		if s == nil {
			continue
		}

		// Convert followers
		var followers []*model.StoreFollower
		for _, f := range s.Followers {
			followers = append(followers, &model.StoreFollower{
				FollowerID:    int(f.FollowerID),
				FollowerName:  f.FollowerName,
				StoreID:       int(f.StoreID),
				FollowerImage: f.FollowerImage,
			})
		}

		// Convert products
		var products []*model.Product
		for _, p := range s.Products {
			products = append(products, &model.Product{
				ID:          int(p.ID),
				Name:        p.Name,
				Price:       p.Price,
				Description: p.Description,
				Discount:    p.Discount,
				Image:       p.Images,
				Slug:        p.Slug,
				Quantity:    p.Quantity,
				Status:      p.Status,
				Thumbnail:   p.Thumbnail,
				Store:       p.Store,
				Category:    p.Category,
				Subcategory: p.Subcategory,
			})
		}

		modelStore := &model.Store{
			ID:                 strconv.Itoa(int(s.ID)),
			Link:               s.Link,
			Name:               s.Name,
			User:               int(s.UserID),
			Description:        s.Description,
			Thumbnail:          s.Thumbnail,
			Phone:              s.Phone,
			Background:         s.Background,
			Address:            s.Address,
			Status:             s.Status,
			HasPhysicalAddress: s.HasPhysicalAddress,
			Wallet:             float64(s.Wallet),
			Visitors:           s.Visitors,
			Followers:          followers,
			Product:            products,
		}
		modelStores = append(modelStores, modelStore)
	}

	return modelStores, nil
}

// Category is the resolver for the Category field.
func (r *queryResolver) Category(ctx context.Context, id int) (*model.Category, error) {
	categoryID := uint32(id)
	category, err := r.ProductHandler.GetCategory(ctx, categoryID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch category: %v", err)
	}

	if category == nil {
		return nil, fmt.Errorf("category not found")
	}

	// Convert SubCategories to the correct type
	subCategories := make([]*model.SubCategory, 0)
	for _, sub := range category.SubCategories {
		subCategories = append(subCategories, &model.SubCategory{
			Name:     sub.Name,
			Slug:     sub.Slug,
			Category: int(sub.CategoryID),
		})
	}

	return &model.Category{
		ID:            strconv.FormatUint(uint64(category.ID), 10),
		Name:          category.Name,
		Slug:          category.Slug,
		Subcategories: subCategories,
	}, nil
}

// SubCategory is the resolver for the SubCategory field.
func (r *queryResolver) SubCategory(ctx context.Context, id string) (*model.SubCategory, error) {
	panic(fmt.Errorf("not implemented: SubCategory - SubCategory"))
}

// Products is the resolver for the Products field.
func (r *queryResolver) Products(ctx context.Context, store *string, categorySlug *string, limit *int, offset *int) (*model.ProductPaginationData, error) {
	fmt.Printf("Received Arguments - limit: %v, offset: %v, store: %v\n", limit, offset, store)

	// Convert nullable parameters
	limitValue := 12
	if limit != nil {
		limitValue = *limit
	}

	offsetValue := 0
	if offset != nil {
		offsetValue = *offset
	}

	storeValue := ""
	if store != nil {
		storeValue = *store
	}

	var products []*product.Product
	var total int
	var err error

	if store != nil && strings.Contains(*store, "-") {
		// This is a search query
		searchQuery := strings.TrimSuffix(*store, "-")
		products, err = r.ProductService.SearchProducts(ctx, searchQuery)
		if err != nil {
			return nil, fmt.Errorf("failed to search products: %v", err)
		}
		total = len(products)
	} else {
		products, total, err = r.ProductService.GetProducts(ctx, storeValue, "", limitValue, offsetValue)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch products: %v", err)
		}
	}

	if products == nil {
		products = []*product.Product{} // Return empty array instead of nil
	}

	// Convert to GraphQL model
	modelProducts := make([]*model.Product, 0, len(products))
	for _, p := range products {
		if p == nil {
			continue
		}
		modelProducts = append(modelProducts, &model.Product{
			ID:              int(p.ID),
			Name:            p.Name,
			Slug:            p.Slug,
			Description:     p.Description,
			Price:           p.Price,
			Discount:        p.Discount,
			Status:          p.Status,
			Quantity:        p.Quantity,
			Thumbnail:       p.Thumbnail,
			Image:           p.Images,
			File:            &p.File,
			Store:           p.Store,
			Category:        p.Category,
			Subcategory:     p.Subcategory,
			AlwaysAvailable: p.AlwaysAvailbale,
		})
	}

	return &model.ProductPaginationData{
		Data:        modelProducts,
		CurrentPage: offsetValue + 1,
		PerPage:     limitValue,
		Total:       total,
		NextPage:    offsetValue + 2,
		PrevPage:    offsetValue,
	}, nil
}

// Product is the resolver for the Product field.
func (r *queryResolver) Product(ctx context.Context, id int) (*model.Product, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert int to uint32 for the handler
	productID := uint32(id)

	// Call the handler with userId 0 since we're just viewing
	p, err := productHandler.GetProduct(ctx, productID, 0)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	return &model.Product{
		ID:              int(p.ID),
		Name:            p.Name,
		Slug:            p.Slug,
		Description:     p.Description,
		Type:            p.Type,
		Price:           p.Price,
		Discount:        p.Discount,
		Status:          p.Status,
		Quantity:        p.Quantity,
		Thumbnail:       p.Thumbnail,
		Image:           p.Images,
		File:            &p.File,
		Store:           p.Store,
		Category:        p.Category,
		Subcategory:     p.Subcategory,
		AlwaysAvailable: p.AlwaysAvailbale,
	}, nil
}

// HandledProducts is the resolver for the HandledProducts field.
func (r *queryResolver) HandledProducts(ctx context.Context, user int, typeArg string) ([]*model.HandledProducts, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert int to uint32 for the handler
	userID := uint32(user)

	// Add debug logging
	fmt.Printf("Fetching handled products for user %d with type %s\n", userID, typeArg)

	// Get handled products from the handler
	products, err := productHandler.GetHandledProducts(ctx, userID, typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch handled products: %v", err)
	}

	// Add debug logging
	fmt.Printf("Found %d products\n", len(products))

	// Initialize empty slice
	handledProducts := make([]*model.HandledProducts, 0)

	// Convert to GraphQL model
	for _, p := range products {
		// Get the actual product details using product ID from handled_products table
		productDetails, err := productHandler.GetProduct(ctx, p.ProductID, 0)
		if err != nil {
			fmt.Printf("Error fetching product details for ID %d: %v\n", p.ProductID, err)
			continue
		}

		if productDetails == nil {
			fmt.Printf("Product details not found for ID %d\n", p.ProductID)
			continue
		}

		status := productDetails.Status
		price := productDetails.Price
		discount := productDetails.Discount
		quantity := productDetails.Quantity
		name := productDetails.Name
		thumbnail := productDetails.Thumbnail

		handledProduct := &model.HandledProducts{
			UserID:           int(p.UserID),
			ProductID:        int(productDetails.ID),
			ProductName:      &name,
			ProductThumbnail: &thumbnail,
			ProductPrice:     &price,
			ProductDiscount:  &discount,
			ProductStatus:    &status,
			ProductQuantity:  &quantity,
		}
		handledProducts = append(handledProducts, handledProduct)

		// Log each product being added
		fmt.Printf("Added product: ID=%d, Name=%s\n", productDetails.ID, name)
	}

	return handledProducts, nil
}

// RecommendedProducts is the resolver for the RecommendedProducts field.
func (r *queryResolver) RecommendedProducts(ctx context.Context, query string) ([]*model.Product, error) {
	panic(fmt.Errorf("not implemented: RecommendedProducts - RecommendedProducts"))
}

// RecentlyAddedProducts is the resolver for the RecentlyAddedProducts field.
func (r *queryResolver) RecentlyAddedProducts(ctx context.Context, user int) ([]*model.Product, error) {
	panic(fmt.Errorf("not implemented: RecentlyAddedProducts - RecentlyAddedProducts"))
}

// Cart is the resolver for the Cart field.
func (r *queryResolver) Cart(ctx context.Context, user int) (*model.Cart, error) {
	cartHandler := cart.NewHandler(cart.NewService(cart.NewRepository()))

	// Convert int to uint32 for the handler
	userID := uint32(user)

	result, err := cartHandler.GetCart(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Convert cart items to GraphQL model
	var cartItems []*model.CartItem
	for _, item := range result.Items {
		cartItem := &model.CartItem{
			Product: &model.Product{
				ID:        int(item.Product.ID),
				Name:      item.Product.Name,
				Price:     item.Product.Price,
				Discount:  item.Product.Discount,
				Quantity:  item.Product.Quantity,
				Thumbnail: item.Product.Thumbnail,
				Image:     item.Product.Images,
				Store:     item.Product.Store,
			},
			Quantity: item.Quantity,
		}
		cartItems = append(cartItems, cartItem)
	}

	// Convert ID to string
	id := strconv.FormatUint(uint64(result.ID), 10)

	return &model.Cart{
		Items:  cartItems,
		Total:  result.Total,
		Active: result.Active,
		User:   int(result.UserID),
		ID:     &id,
	}, nil
}

// SubscriptionBundle is the resolver for the SubscriptionBundle field.
func (r *queryResolver) SubscriptionBundle(ctx context.Context, serviceID string) (*model.SubscriptionBundle, error) {
	panic(fmt.Errorf("not implemented: SubscriptionBundle - SubscriptionBundle"))
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, query string) ([]*model.Product, error) {
	products, err := r.ProductHandler.SearchProducts(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to search products: %v", err)
	}

	// Convert to GraphQL model
	modelProducts := make([]*model.Product, 0, len(products))
	for _, p := range products {
		if p == nil {
			continue
		}
		modelProducts = append(modelProducts, &model.Product{
			ID:              int(p.ID),
			Name:            p.Name,
			Slug:            p.Slug,
			Description:     p.Description,
			Price:           p.Price,
			Discount:        p.Discount,
			Status:          p.Status,
			Quantity:        p.Quantity,
			Thumbnail:       p.Thumbnail,
			Image:           p.Images,
			File:            &p.File,
			Store:           p.Store,
			Category:        p.Category,
			Subcategory:     p.Subcategory,
			AlwaysAvailable: p.AlwaysAvailbale,
		})
	}

	return modelProducts, nil
}

// Stores is the resolver for the Stores field.
func (r *queryResolver) Stores(ctx context.Context, user *int, limit *int, offset *int) (*model.StorePaginationData, error) {
	// Convert nullable parameters to concrete values
	userID := uint32(*user)
	limitValue := 100
	if limit != nil {
		limitValue = *limit
	}
	offsetValue := 0
	if offset != nil {
		offsetValue = *offset
	}

	// Get stores from repository
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
	stores, err := storeHandler.GetStores(ctx, userID, limitValue, offsetValue)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch stores: %v", err)
	}

	// Convert to GraphQL model
	var modelStores []*model.Store
	for _, s := range stores {
		if s == nil {
			continue
		}

		// Convert followers
		var followers []*model.StoreFollower
		for _, f := range s.Followers {
			followers = append(followers, &model.StoreFollower{
				FollowerID:    int(f.FollowerID),
				FollowerName:  f.FollowerName,
				StoreID:       int(f.StoreID),
				FollowerImage: f.FollowerImage,
			})
		}

		// Convert products
		var products []*model.Product
		for _, p := range s.Products {
			products = append(products, &model.Product{
				ID:          int(p.ID),
				Name:        p.Name,
				Price:       p.Price,
				Description: p.Description,
				Discount:    p.Discount,
				Image:       p.Images,
				Slug:        p.Slug,
				Quantity:    p.Quantity,
				Status:      p.Status,
				Thumbnail:   p.Thumbnail,
				Store:       p.Store,
				Category:    p.Category,
				Subcategory: p.Subcategory,
			})
		}

		// Convert withdrawal accounts
		var accounts []*model.WithdrawAccount
		for _, a := range s.Accounts {
			accounts = append(accounts, &model.WithdrawAccount{
				BankCode:      a.BankCode,
				BankName:      a.BankName,
				BankImage:     a.BankImage,
				AccountNumber: a.AccountNumber,
				AccountName:   a.AccountName,
			})
		}

		modelStore := &model.Store{
			ID:                 strconv.Itoa(int(s.ID)), // Convert ID to string
			Link:               s.Link,
			Name:               s.Name,
			User:               int(s.UserID),
			Description:        s.Description,
			Thumbnail:          s.Thumbnail,
			Phone:              s.Phone,
			Background:         s.Background,
			Address:            s.Address,
			Status:             s.Status,
			HasPhysicalAddress: s.HasPhysicalAddress,
			Wallet:             float64(s.Wallet), // Convert Wallet to float64
			Visitors:           s.Visitors,
			Followers:          followers,
			Product:            products,
			Accounts:           accounts,
		}
		modelStores = append(modelStores, modelStore)
	}

	return &model.StorePaginationData{
		Data:        modelStores,
		CurrentPage: offsetValue + 1,
		PerPage:     limitValue,
		Total:       len(modelStores),
	}, nil
}

// Store is the resolver for the Store field.
func (r *queryResolver) Store(ctx context.Context, id int) (*model.Store, error) {
	panic(fmt.Errorf("not implemented: Store - Store"))
}

// Reviews is the resolver for the Reviews field.
func (r *queryResolver) Reviews(ctx context.Context, id string, value string) ([]*model.Review, error) {
	panic(fmt.Errorf("not implemented: Reviews - Reviews"))
}

// StoreByName is the resolver for the StoreByName field.
func (r *queryResolver) StoreByName(ctx context.Context, name string) (*model.Store, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get store by name
	s, err := storeHandler.GetStoreByName(ctx, name)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch store: %v", err)
	}

	// Convert followers to GraphQL model
	var followers []*model.StoreFollower
	for _, f := range s.Followers {
		followers = append(followers, &model.StoreFollower{
			FollowerID:    int(f.FollowerID),
			FollowerName:  f.FollowerName,
			StoreID:       int(f.StoreID),
			FollowerImage: f.FollowerImage,
		})
	}

	// Convert products to GraphQL model
	var products []*model.Product
	for _, p := range s.Products {
		products = append(products, &model.Product{
			ID:          int(p.ID),
			Name:        p.Name,
			Price:       p.Price,
			Description: p.Description,
			Discount:    p.Discount,
			Image:       p.Images,
			Slug:        p.Slug,
			Quantity:    p.Quantity,
			Status:      p.Status,
			Thumbnail:   p.Thumbnail,
			Store:       p.Store,
			Category:    p.Category,
			Subcategory: p.Subcategory,
		})
	}

	return &model.Store{
		ID:                 strconv.Itoa(int(s.ID)),
		Link:               s.Link,
		Name:               s.Name,
		User:               int(s.UserID),
		Description:        s.Description,
		Thumbnail:          s.Thumbnail,
		Phone:              s.Phone,
		Background:         s.Background,
		Address:            s.Address,
		Status:             s.Status,
		HasPhysicalAddress: s.HasPhysicalAddress,
		Wallet:             float64(s.Wallet),
		Visitors:           s.Visitors,
		Followers:          followers,
		Product:            products,
	}, nil
}

// PurchasedOrder is the resolver for the PurchasedOrder field.
func (r *queryResolver) PurchasedOrder(ctx context.Context, user int) ([]*model.PurchasedOrder, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Pass the user ID directly as integer
	orders, err := storeHandler.GetPurchasedOrders(ctx, fmt.Sprintf("%d", user))
	if err != nil {
		// Check for specific error types
		switch {
		case strings.Contains(err.Error(), "record not found"):
			// Return empty array if no orders found
			return []*model.PurchasedOrder{}, nil
		case strings.Contains(err.Error(), "<!DOCTYPE"):
			// Return empty array for HTML response
			return []*model.PurchasedOrder{}, nil
		case strings.Contains(err.Error(), "unsupported relations"):
			// Return empty array for relation errors
			return []*model.PurchasedOrder{}, nil
		default:
			return nil, fmt.Errorf("failed to fetch purchased orders: %v", err)
		}
	}

	if orders == nil {
		return []*model.PurchasedOrder{}, nil
	}

	// Rest of the conversion code remains the same
	var purchasedOrders []*model.PurchasedOrder
	for _, order := range orders {
		if order == nil {
			continue
		}

		// Convert tracked products with nil check
		var products []*model.TrackedProduct
		if order.Products != nil {
			for _, p := range order.Products {
				products = append(products, &model.TrackedProduct{
					ID:        int(p.ID),
					Name:      p.Name,
					Price:     p.Price,
					Thumbnail: p.Thumbnail,
					Discount:  p.Discount,
					Status:    p.Status,
				})
			}
		}

		// Convert delivery details with nil check
		var deliveryDetails *model.DeliveryDetails
		if order.DeliveryDetails != (store.DeliveryDetails{}) {
			deliveryDetails = &model.DeliveryDetails{
				Method:  order.DeliveryDetails.Method,
				Address: order.DeliveryDetails.Address,
				Fee:     order.DeliveryDetails.Fee,
			}
		}

		purchasedOrder := &model.PurchasedOrder{
			CartID:          int(order.CartID),
			Coupon:          order.Coupon,
			Fee:             order.Fee,
			Status:          order.Status,
			UserID:          order.UserID,
			Amount:          order.Amount,
			UUID:            order.UUID,
			PaymentGateway:  order.PaymentGateway,
			PaymentMethod:   order.PaymentMethod,
			TransRef:        order.TransRef,
			TransStatus:     order.TransStatus,
			Products:        products,
			DeliveryDetails: deliveryDetails,
			TextRef:         order.TransRef,
		}
		purchasedOrders = append(purchasedOrders, purchasedOrder)
	}

	return purchasedOrders, nil
}

// Skynets is the resolver for the Skynets field.
func (r *queryResolver) Skynets(ctx context.Context, id string) ([]*model.Skynet, error) {
	panic(fmt.Errorf("not implemented: Skynets - Skynets"))
}

// Skynet is the resolver for the Skynet field.
func (r *queryResolver) Skynet(ctx context.Context, id string) (*model.Skynet, error) {
	panic(fmt.Errorf("not implemented: Skynet - Skynet"))
}

// Mydva is the resolver for the MYDVA field.
func (r *queryResolver) Mydva(ctx context.Context, email string) (*model.Account, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	account, err := storeHandler.GetDVAAccount(ctx, email)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch DVA account: %v", err)
	}

	// Convert string ID to uint64
	id, err := strconv.ParseUint(account.ID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid account ID: %v", err)
	}

	// Convert customer ID to int
	customerID, err := strconv.Atoi(account.Customer.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid customer ID: %v", err)
	}

	// Convert bank ID to int
	bankID, err := strconv.Atoi(account.Bank.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid bank ID: %v", err)
	}

	return &model.Account{
		Customer: &model.Customer{
			ID:        strconv.Itoa(customerID),
			FirstName: account.Customer.Email,
			LastName:  "",
		},
		Bank: &model.Bank{
			ID:   strconv.Itoa(bankID), // Use the converted bankID here
			Name: account.Bank.Name,
			Slug: account.Bank.Slug,
		},
		ID:            strconv.FormatUint(id, 10),
		AccountNumber: account.AccountNumber,
		AccountName:   account.AccountName,
	}, nil
}

// GetDVABalance is the resolver for the GetDVABalance field.
func (r *queryResolver) GetDVABalance(ctx context.Context, accountNumber string) (*string, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	balance, err := storeHandler.GetDVABalance(ctx, accountNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch DVA balance: %v", err)
	}

	balanceStr := strconv.FormatFloat(balance, 'f', 2, 64)
	return &balanceStr, nil
}

// MyInvoices is the resolver for the MyInvoices field.
func (r *queryResolver) MyInvoices(ctx context.Context, storeID *int) ([]*model.Invoice, error) {
	panic(fmt.Errorf("not implemented: MyInvoices - MyInvoices"))
}

// MyDownloads is the resolver for the MyDownloads field.
func (r *queryResolver) MyDownloads(ctx context.Context, id string) ([]*model.Downloads, error) {
	panic(fmt.Errorf("not implemented: MyDownloads - MyDownloads"))
}

// Add/Update the Chats query resolver
func (r *queryResolver) Chats(ctx context.Context, userID string) ([]*model.Chat, error) {
	// Convert userID string to uint32
	uid, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %v", err)
	}

	// Use GetChatLists instead of GetChatsByUserID
	chats, err := r.MessageHandler.GetChatLists(ctx, uint32(uid))
	if err != nil {
		return nil, fmt.Errorf("failed to get user chats: %v", err)
	}

	var result []*model.Chat
	for _, chat := range chats {
		var messages []*model.Message
		for _, msg := range chat.Messages {
			// Get user details for the sender
			senderUser, err := r.UserHandler.GetUser(ctx, strconv.FormatUint(uint64(msg.Sender), 10))
			if err != nil {
				log.Printf("Error fetching user details: %v", err)
				continue
			}

			var mediaStr *string
			if msg.Media != nil {
				s := string(*msg.Media)
				mediaStr = &s
			}

			// Create user model
			user := &model.User{
				ID:       strconv.FormatUint(uint64(senderUser.ID), 10),
				Fullname: senderUser.Fullname,
				Avatar:   &senderUser.Avatar,
				Online:   senderUser.Online,
			}

			messages = append(messages, &model.Message{
				ID:        strconv.FormatInt(int64(msg.ID), 10),
				ChatID:    strconv.FormatInt(int64(msg.ChatID), 10),
				Content:   msg.Content,
				Sender:    strconv.FormatInt(int64(msg.Sender), 10),
				Media:     mediaStr,
				IsRead:    msg.IsRead,
				Users:     []*model.User{user}, // Add user details here
				CreatedAt: msg.CreatedAt.Format(time.RFC3339),
				UpdatedAt: func() *string {
					if !msg.UpdatedAt.IsZero() {
						t := msg.UpdatedAt.Format(time.RFC3339)
						return &t
					}
					return nil
				}(),
			})
		}

		result = append(result, &model.Chat{
			ID:            strconv.FormatInt(int64(chat.ID), 10),
			Messages:      messages,
			LatestMessage: nil, // Add latest message if needed
			UnreadCount:   chat.UnreadCount,
		})
	}

	return result, nil
}

// Fix the Messages query resolver
func (r *queryResolver) Messages(ctx context.Context, chatID string) ([]*model.Message, error) {
	messages, err := r.MessageHandler.GetMessages(ctx, chatID)
	if err != nil {
		return nil, err
	}

	var result []*model.Message
	for _, msg := range messages {
		createdAt := msg.CreatedAt.Format(time.RFC3339)
		var updatedAt *string
		if !msg.UpdatedAt.IsZero() {
			t := msg.UpdatedAt.Format(time.RFC3339)
			updatedAt = &t
		}

		result = append(result, &model.Message{
			ID:        strconv.FormatInt(int64(msg.ID), 10),
			ChatID:    strconv.FormatInt(int64(msg.ChatID), 10),
			Content:   msg.Content,
			Sender:    strconv.FormatInt(int64(msg.Sender), 10),
			Media:     (*string)(msg.Media),
			IsRead:    msg.IsRead,
			CreatedAt: createdAt,
			UpdatedAt: updatedAt,
		})
	}

	return result, nil
}

// GetDVAAccount is the resolver for the GetDVAAccount field.
func (r *queryResolver) GetDVAAccount(ctx context.Context, userID string) (*model.DVAAccount, error) {
	// Get DVA account details using the userID string directly
	dvaAccount, err := r.UserHandler.GetDVAAccount(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get DVA account: %v", err)
	}

	// Check if dvaAccount or its nested fields are nil
	if dvaAccount == nil {
		return nil, fmt.Errorf("DVA account not found")
	}

	// Convert to GraphQL model
	return &model.DVAAccount{
		ID:            dvaAccount.ID,
		AccountName:   dvaAccount.AccountName,
		AccountNumber: dvaAccount.AccountNumber,
		Customer: &model.Customer{
			ID:        dvaAccount.Customer.ID,
			Email:     dvaAccount.Customer.Email,
			FirstName: "",
			LastName:  "",
		},
		Bank: &model.Bank{ // Changed from DVABank to Bank
			ID:   dvaAccount.Bank.ID,
			Name: dvaAccount.Bank.Name,
			Slug: dvaAccount.Bank.Slug,
		},
	}, nil
}

// ProductSearchResults is the resolver for the productSearchResults field.
func (r *subscriptionResolver) ProductSearchResults(ctx context.Context, query string) (<-chan []*model.Product, error) {
	panic(fmt.Errorf("not implemented: ProductSearchResults - productSearchResults"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
