package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"errors"
	"fmt"
	"math"
	"strconv"
	"strings"
	"time"

	"github.com/Chrisentech/aluta-market-api/app"
	"github.com/Chrisentech/aluta-market-api/graph/model"
	"github.com/Chrisentech/aluta-market-api/internals/cart"
	"github.com/Chrisentech/aluta-market-api/internals/messages"
	"github.com/Chrisentech/aluta-market-api/internals/product"
	"github.com/Chrisentech/aluta-market-api/internals/skynet"
	"github.com/Chrisentech/aluta-market-api/internals/store"
	"github.com/Chrisentech/aluta-market-api/internals/user"
	"github.com/Chrisentech/aluta-market-api/middlewares"
	"github.com/Chrisentech/aluta-market-api/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	userReq := &user.CreateUserReq{
		Fullname: input.Fullname,
		Email:    input.Email,
		Campus:   input.Campus,
		Password: input.Password,
		Phone:    input.Phone,
		Usertype: input.Usertype,
		// Code:       input.Code,
	}
	if input.Usertype == "seller" {
		userReq.StoreName = input.Stores.Name
		userReq.StoreLink = input.Stores.Link
		userReq.StoreAddress = input.Stores.Address
		userReq.Description = input.Stores.Description
		userReq.HasPhysicalAddress = input.Stores.HasPhysicalAddress
		userReq.StorePhone = input.Stores.Phone
	}
	_, err := userHandler.CreateUser(ctx, userReq)

	if err != nil {
		return nil, err
	}
	user := &model.User{
		Fullname: input.Fullname,
		Email:    input.Email,
		Campus:   input.Campus,
		Password: input.Password,
		Phone:    input.Phone,
		Usertype: input.Usertype,
	}
	// Append the newly created store to the user's Stores slice
	// user.Stores = append(user.Stores,input.Stores.ID)
	// user.Stores = append(user.Stores,input.St)
	return user, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.StoreOrderInput) (*model.StoreOrder, error) {
	storeRep := app.InitializePackage(app.StorePackage)
	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a store.Repository")
	}

	storeSrvc := store.NewService(storeRepository)

	storeHandler := store.NewHandler(storeSrvc)
	storeInput := &store.StoreOrder{
		StoreID: input.StoreID,
		Status:  input.Status,
		Customer: store.Customer{
			Name:    input.Customer.Name,
			Phone:   input.Customer.Phone,
			Address: input.Customer.Address,
		},
	}
	// Convert []*model.ProductInput to []*store.Product
	var products []*store.StoreProduct

	for _, p := range input.Product {
		var id uint32
		if p.ID != nil {
			parsedID, err := strconv.ParseUint(*p.ID, 10, 32)
			if err != nil {
				return nil, fmt.Errorf("invalid product ID: %v", err)
			}
			id = uint32(parsedID)
		}
		newEntryPrd := store.StoreProduct{
			ID:        id,
			Name:      p.Name,
			Quantity:  p.Quantity,
			Price:     p.Price,
			Thumbnail: p.Thumbnail,
		}
		products = append(products, &newEntryPrd)
	}
	storeInput.Products = products
	resp, err := storeHandler.CreateOrder(ctx, storeInput)
	if err != nil {
		return nil, err
	}
	output := &model.StoreOrder{
		StoreID:  resp.StoreID,
		Status:   resp.Status,
		Customer: &model.StoreCustomer{Name: resp.Customer.Name, Phone: resp.Customer.Phone, Address: resp.Customer.Address},
	}
	return output, nil
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, input model.UpdateStoreOrderInput) (*model.StoreOrder, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	storeRep := app.InitializePackage(app.StorePackage)
	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a store.Repository")
	}

	storeSrvc := store.NewService(storeRepository)

	storeHandler := store.NewHandler(storeSrvc)

	orderInput := &store.UpdateStoreOrderInput{UUID: *input.ID, Status: *input.Status}
	if input.StoreID != nil {
		storeID, err := strconv.ParseUint(*input.StoreID, 10, 32)
		if err != nil {
			fmt.Println("Invalid StoreID:", err)
			return nil, err
		}
		orderInput.StoreID = uint32(storeID)
	} else {
		fmt.Println("StoreID is nil")
		return nil, nil
	}
	// orderInput.StoresID = append(orderInput.StoresID, input.StoreID)

	resp, err := storeHandler.UpdateOrder(ctx, orderInput)
	if err != nil {
		return nil, err
	}
	output := &model.StoreOrder{
		// StoreID:  resp.StoreID,
		Status:   resp.Status,
		Customer: &model.StoreCustomer{Name: resp.Customer.Name, Phone: resp.Customer.Phone, Address: resp.Customer.Address},
	}
	return output, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input *model.UpdateUserInput) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	usr := &user.User{}
	if input.Fullname != nil {
		usr.Fullname = *input.Fullname
	}
	if input.Email != nil {
		usr.Email = *input.Email
	}
	if input.Avatar != nil {
		usr.Avatar = *input.Avatar
	}
	if input.Phone != nil {
		usr.Phone = *input.Phone
	}
	if input.Gender != nil {
		usr.Gender = *input.Gender
	}
	if input.Dob != nil {
		usr.Dob = *input.Dob
	}
	if input.Online != nil {
		usr.Online = *input.Online
	}
	if input.Usertype != nil {
		usr.Usertype = *input.Usertype
	}

	if input.UUID != nil {
		usr.UUID = *input.UUID
	}

	if input.PaymnetDetails != nil {
		usr.PaymentDetails.Name = input.PaymnetDetails.Name
		usr.PaymentDetails.Phone = input.PaymnetDetails.Phone
		usr.PaymentDetails.Address = input.PaymnetDetails.Address
		usr.PaymentDetails.Info = input.PaymnetDetails.Info
	}

	if input.ID != nil {
		idUint64, err := strconv.ParseUint(*input.ID, 10, 32)
		if err != nil {
			fmt.Println("Error converting ID:", err)
		} else {
			usr.ID = uint32(idUint64)
		}
	}
	resp, err := userHandler.UpdateUser(ctx, usr)

	if err != nil {
		return nil, err
	}
	modalResp := &model.User{
		ID:       strconv.FormatUint(uint64(resp.ID), 10),
		Fullname: resp.Fullname,
		Email:    resp.Email,
		Avatar:   &resp.Avatar,
		Phone:    resp.Phone,
		Usertype: resp.Usertype,
	}
	return modalResp, nil
}

// CreateVerifyOtp is the resolver for the createVerifyOTP field.
func (r *mutationResolver) CreateVerifyOtp(ctx context.Context, input model.NewVerifyOtp) (*model.LoginRes, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)

	req := &user.VerifyOTPReq{
		Phone: input.Phone,
		// Email: *input.Email,
		Code:     input.Code,
		Attempts: input.Attempts,
	}
	resp, err := userHandler.VerifyOTP(ctx, req)
	if err != nil {
		return nil, err
	}
	schema := &model.LoginRes{
		ID:           int(resp.ID),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
	}
	return schema, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginReq) (*model.LoginRes, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	req := &user.LoginUserReq{
		Email:    input.Email,
		Password: input.Password,
	}
	resp, err := userHandler.Login(ctx, req)
	if err != nil {
		return nil, err
	}
	schema := &model.LoginRes{
		ID:           int(resp.ID),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
	}
	return schema, nil
}

// AddHandledProduct is the resolver for the addHandledProduct field.
func (r *mutationResolver) AddHandledProduct(ctx context.Context, userID int, productID int, typeArg string) (*model.HandledProducts, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	prod, err := productHandler.AddHandledProduct(ctx, uint32(userID), uint32(productID), typeArg)
	if err != nil {
		return nil, err
	}
	schema := &model.HandledProducts{
		UserID:           userID,
		ProductID:        productID,
		ProductName:      &prod.Product.Name,
		ProductThumbnail: &prod.Product.Thumbnail,
		ProductQuantity:  &prod.Product.Quantity,
		ProductStatus:    &prod.Product.Status,
		ProductPrice:     &prod.Product.Price,
		ProductDiscount:  &prod.Product.Discount,
	}
	return schema, nil
}

// AddReview is the resolver for the addReview field.
func (r *mutationResolver) AddReview(ctx context.Context, input model.ReviewInput) (*model.Review, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newReview := &product.Review{
		Username:  input.Username,
		Image:     input.Image,
		Message:   input.Message,
		Rating:    input.Rating,
		ProductID: uint32(input.ProductID),
	}
	resp, err := productHandler.AddReview(ctx, newReview)
	if err != nil {
		return nil, err
	}
	NewReview := &model.Review{
		Username:  resp.Username,
		Image:     resp.Image,
		Message:   resp.Message,
		Rating:    resp.Rating,
		ProductID: int(resp.ProductID),
	}

	return NewReview, nil
}

// CheckStoreName is the resolver for the checkStoreName field.
func (r *mutationResolver) CheckStoreName(ctx context.Context, input string) (*string, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a cart.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	err := storeHandler.CheckStoreName(ctx, strings.ToLower(strings.TrimSpace(input)))
	if err != nil {
		return nil, err
	}
	return &input, nil
}

// UpdateStoreFollower is the resolver for the updateStoreFollower field.
func (r *mutationResolver) UpdateStoreFollower(ctx context.Context, input *model.StoreFollowerInput) (*model.Store, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a cart.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)
	follower := &store.Follower{
		FollowerID:    uint32(input.FollowerID),
		FollowerName:  input.FollowerName,
		FollowerImage: input.FollowerImage,
		StoreID:       uint32(input.StoreID),
	}

	userRep := app.InitializePackage(app.UserPackage)

	userRepository, _ := userRep.(user.Repository)
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	userHandler.ToggleStoreFollowStatus(ctx, uint32(input.FollowerID), uint32(input.StoreID))
	resp, err := storeHandler.UpdateStoreFollowership(ctx, uint32(input.StoreID), follower, input.Action)
	if err != nil {
		return nil, err
	}
	store := &model.Store{
		ID:                 strconv.Itoa(int(resp.ID)),
		Name:               resp.Name,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Link:               resp.Link,
		Wallet:             resp.Wallet,
		User:               int(resp.UserID),
		Description:        resp.Description,
		Thumbnail:          resp.Thumbnail,
		Background:         resp.Background,
		Address:            resp.Address,
		Phone:              resp.Phone,
		Visitors:           resp.Visitors,
	}
	for _, follower := range resp.Followers {
		storeFollower := &model.StoreFollower{}
		storeFollower.FollowerID = int(follower.ID)
		storeFollower.FollowerName = follower.FollowerName
		store.Followers = append(store.Followers, storeFollower)
	}

	return store, nil
}

// CreateSkynet is the resolver for the createSkynet field.
func (r *mutationResolver) CreateSkynet(ctx context.Context, input *model.SkynetInput) (string, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("", token)
	// if authErr != nil {
	// 	return "", authErr
	// }
	skynetRep := app.InitializePackage(app.SkynetPackage)

	skynetRepository, ok := skynetRep.(skynet.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return "", fmt.Errorf("skynetRep is not a skynet.Repository")
	}
	skynetSrvc := skynet.NewService(skynetRepository)
	skynetHandler := skynet.NewHandler(skynetSrvc)
	skynetAirtimeInput := &skynet.Airtime{}
	skynetDataInput := &skynet.Data{}
	skynetTVSubInput := &skynet.TVSubscription{}
	skynetEducationInput := &skynet.EducationPayment{}

	if input.Type == "airtime" {
		skynetAirtimeInput.Amount = int64(input.Amount)
		skynetAirtimeInput.UserID = uint32(input.UserID)
		skynetAirtimeInput.ServiceID = input.ServiceID
		skynetAirtimeInput.Phone = *input.PhoneNumber

		resp, err := skynetHandler.BuyAirtime(ctx, skynetAirtimeInput)
		if err != nil {
			return "", err
		}
		return *resp, nil
	}
	if input.Type == "data" {
		skynetDataInput.Amount = int64(input.Amount)
		skynetDataInput.UserID = uint32(input.UserID)
		skynetDataInput.ServiceID = input.ServiceID
		skynetDataInput.Phone = *input.PhoneNumber
		skynetDataInput.BillersCode = *input.BillersCode
		skynetDataInput.VariationCode = *input.VariantCode

		resp, err := skynetHandler.BuyData(ctx, skynetDataInput)
		if err != nil {
			return "", err
		}
		return *resp, nil
	}

	if input.Type == "tv_sub" {
		skynetTVSubInput.Amount = int64(input.Amount)
		skynetTVSubInput.UserID = uint32(input.UserID)
		skynetTVSubInput.ServiceID = input.ServiceID
		skynetTVSubInput.Phone = *input.PhoneNumber
		skynetTVSubInput.BillersCode = *input.BillersCode
		skynetTVSubInput.VariationCode = *input.VariantCode
		skynetTVSubInput.SubscriptionType = *input.SubscriptionType

		resp, err := skynetHandler.BuyTVSubscription(ctx, skynetTVSubInput)
		if err != nil {
			return "", err
		}
		return *resp, nil
	}

	if input.Type == "education" {
		skynetEducationInput.Amount = int64(input.Amount)
		skynetEducationInput.UserID = uint32(input.UserID)
		skynetEducationInput.ServiceID = input.ServiceID
		skynetEducationInput.Phone = *input.PhoneNumber
		skynetEducationInput.BillersCode = *input.BillersCode
		skynetEducationInput.VariationCode = *input.VariantCode
		skynetEducationInput.Quantity = *input.Quantity

		resp, err := skynetHandler.BuyEducational(ctx, skynetEducationInput)
		if err != nil {
			return "", err
		}
		return *resp, nil
	}
	return "", errors.New("type is required")
}

// RemoveHandledProduct is the resolver for the removeHandledProduct field.
func (r *mutationResolver) RemoveHandledProduct(ctx context.Context, prd int, typeArg *string) (*model.HandledProducts, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	err := productHandler.RemoveHandledProduct(ctx, uint32(prd), *typeArg)
	if err != nil {
		return nil, err
	}
	schema := &model.HandledProducts{
		ProductID: prd,
	}
	return schema, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.NewCategory) (*model.Category, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("admin", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newCategory := &product.Category{
		Name: input.Name,
	}
	resp, err := productHandler.CreateCategory(ctx, newCategory)
	if err != nil {
		return nil, err
	}
	schema := &model.Category{
		Name: resp.Name,
		Slug: utils.GenerateSlug(resp.Name),
	}
	return schema, nil
}

// CreateSubCategory is the resolver for the createSubCategory field.
func (r *mutationResolver) CreateSubCategory(ctx context.Context, input model.NewSubCategory) (*model.SubCategory, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("admin", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newSubCategory := product.SubCategory{
		Name:       input.Name,
		CategoryID: uint32(input.Category),
	}
	resp, err := productHandler.CreateSubCategory(ctx, newSubCategory)
	if err != nil {
		return nil, err
	}
	schema := &model.SubCategory{
		Name:     resp.Name,
		Slug:     utils.GenerateSlug(resp.Name),
		Category: input.Category,
	}
	return schema, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	productRep := app.InitializePackage(app.ProductPackage)
	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	initStatus := true
	// Create a new product
	newProduct := &product.NewProduct{
		Name:            input.Name,
		Description:     input.Description,
		Images:          input.Image,
		Price:           input.Price,
		Discount:        input.Discount,
		File:            input.File,
		Quantity:        input.Quantity,
		Status:          &initStatus,
		Thumbnail:       input.Thumbnail,
		CategoryID:      uint8(input.Category),
		SubCategoryID:   uint8(input.Subcategory),
		Store:           input.Store,
		AlwaysAvailbale: input.AlwaysAvailable,
	}

	// Create product variants and their values
	for _, variantInput := range input.Variant {
		productVariant := &product.VariantType{Name: variantInput.Name}
		var variantValues []*product.VariantValue

		for _, val := range variantInput.Value {
			variantValue := &product.VariantValue{
				Value:  val.Value,
				Price:  *val.Price,
				Images: val.Images,
			}
			variantValues = append(variantValues, variantValue)
		}

		productVariant.Value = variantValues
		newProduct.Variant = append(newProduct.Variant, productVariant)
	}

	// Create the product using the handler
	resp, err := productHandler.CreateProduct(ctx, newProduct)
	if err != nil {
		return nil, err
	}

	// Transform and return the response
	schema := &model.Product{
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Images,
		Price:       resp.Price,
		Discount:    resp.Discount,
		Status:      true,
		Slug:        utils.GenerateSlug(resp.Name),
		Thumbnail:   resp.Thumbnail,
		Category:    resp.Category,
		Store:       resp.Store,
		Subcategory: resp.Subcategory,
	}

	if len(resp.Variant) != 0 {
		for _, outerItem := range resp.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			schema.Variant = append(schema.Variant, productVariant)
		}
	}

	return schema, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input *model.UpdateProductInput) (*model.Product, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	productRep := app.InitializePackage(app.ProductPackage)
	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	mod := &product.NewProduct{}
	mod.ID = input.ID

	if input.Name != nil {
		mod.Name = *input.Name
	}
	if input.Description != nil {
		mod.Description = *input.Description
	}
	if input.Price != nil {
		mod.Price = *input.Price
	}

	if input.Status != nil {
		mod.Status = input.Status
	}

	if input.Quantity != nil {
		mod.Quantity = *input.Quantity
	}

	if input.Category != nil {
		mod.CategoryID = uint8(*input.Category)
	}

	if input.Subcategory != nil {
		mod.SubCategoryID = uint8(*input.Subcategory)
	}

	if input.Thumbnail != nil {
		mod.Thumbnail = *input.Thumbnail
	}

	resp, err := productHandler.UpdateProduct(ctx, mod)
	if err != nil {
		return nil, err
	}

	modResp := &model.Product{
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Images,
		Price:       resp.Price,
		Status:      resp.Status,
		Quantity:    resp.Quantity,
		Slug:        resp.Slug,
		Store:       resp.Store,
		Category:    resp.Category,
		Subcategory: resp.Subcategory,
		Thumbnail:   resp.Thumbnail,
	}
	if len(resp.Variant) != 0 {
		for _, outerItem := range resp.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			modResp.Variant = append(modResp.Variant, productVariant)
		}
	}

	if len(resp.Reviews) != 0 {
		for _, review := range resp.Reviews {
			modelReview := &model.Review{
				Rating:    review.Rating,
				Message:   review.Message,
				Image:     review.Image,
				ProductID: int(review.ProductID), //to be reviewed later
				ID:        &review.ID,
				Username:  review.Username,
			}
			modResp.Review = append(modResp.Review, modelReview)
		}
	}

	return modResp, nil
}

// ToggleStoreFollowStatus is the resolver for the toggleStoreFollowStatus field.
func (r *mutationResolver) ToggleStoreFollowStatus(ctx context.Context, user int, store int) (*string, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	panic(fmt.Errorf("not implemented: ToggleStoreFollowStatus - toggleStoreFollowStatus"))
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, productID int) (*model.Product, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("seller", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	productRep := app.InitializePackage(app.ProductPackage)
	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	product, _ := productHandler.GetProduct(ctx, uint32(productID), 0)
	modPrd := &model.Product{
		Name: product.Name,
	}
	err := productHandler.DeleteProduct(ctx, uint32(productID))
	if err != nil {
		return nil, err
	}

	return modPrd, nil
}

// ModifyCart is the resolver for the ModifyCart field.
func (r *mutationResolver) ModifyCart(ctx context.Context, input model.ModifyCartItemInput) (*model.Cart, error) {
	var cartItem cart.CartItems
	cartItem.Quantity = input.Quantity

	num, _ := strconv.ParseUint(*input.ProductID, 10, 32)
	cartItem.Product = &product.Product{ID: uint32(num)}

	if input.ProductName != nil {
		cartItem.Product = &product.Product{ID: uint32(num), Name: *input.ProductName}
	}

	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)

	resp, err := cartHandler.ModifyCart(ctx, &cartItem, uint32(input.User))

	if err != nil {
		// Handle the error, possibly by logging it or returning it to the client
		return nil, err
	}
	var modelCartItems []*model.CartItem
	for _, item := range resp.Items {
		modelProduct := &model.Product{
			ID:        int(item.Product.ID),
			Quantity:  item.Product.Quantity,
			Price:     item.Product.Price,
			Discount:  item.Product.Discount,
			Name:      item.Product.Name,
			Thumbnail: item.Product.Thumbnail,
			Image:     item.Product.Images,
			Store:     item.Product.Store,
		}

		modelItem := &model.CartItem{
			Product:  modelProduct,
			Quantity: int(item.Quantity),
		}

		modelCartItems = append(modelCartItems, modelItem)
	}
	// Now you need to construct the cart object with the accumulated cartItems
	newCart := &model.Cart{
		// Set the appropriate values for Total, User, and Active
		Total:  resp.Total,       // Replace with the actual total
		User:   int(resp.UserID), // Replace with the actual user ID
		Active: true,             // Replace with the actual active status
		Items:  modelCartItems,
		ID:     uint32ToStringPtr(resp.ID),
	}

	return newCart, nil
}

// RemoveAllCart is the resolver for the removeAllCart field.
func (r *mutationResolver) RemoveAllCart(ctx context.Context, cartID int) (*model.Cart, error) {
	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	err := cartHandler.RemoveAllCart(ctx, uint32(cartID))
	if err != nil {
		return nil, err
	}
	deletedCart := &model.Cart{}
	return deletedCart, nil
}

// CreateStore is the resolver for the createStore field.
func (r *mutationResolver) CreateStore(ctx context.Context, input model.StoreInput) (*model.Store, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	storeRep := app.InitializePackage(app.UserPackage)

	storeRepository, ok := storeRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a cart.Repository")
	}
	storeSrvc := user.NewService(storeRepository)
	storeHandler := user.NewHandler(storeSrvc)

	mod := &store.Store{
		Name:               input.Name,
		UserID:             uint32(input.User),
		Link:               input.Link,
		Description:        input.Description,
		HasPhysicalAddress: input.HasPhysicalAddress,
		Address:            input.Address,
		Wallet:             float64(input.Wallet),
		Status:             input.Status,
	}
	if input.Address != "" {
		mod.HasPhysicalAddress = true
	}
	if input.Thumbnail != nil {
		mod.Thumbnail = *input.Thumbnail
	}
	if input.Background != nil {
		mod.Background = *input.Background
	}
	resp, err := storeHandler.CreateStore(ctx, mod)
	if err != nil {
		return nil, err
	}
	storeMod := &model.Store{
		Name:               resp.Name,
		User:               int(resp.UserID),
		Description:        resp.Description,
		Link:               resp.Link,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Address:            resp.Address,
		Wallet:             resp.Wallet,
		Thumbnail:          resp.Thumbnail,
		Background:         resp.Background,
	}

	return storeMod, nil
}

// UpdateStore is the resolver for the updateStore field.
func (r *mutationResolver) UpdateStore(ctx context.Context, input *model.UpdateStoreInput) (*model.Store, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a cart.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	mod := &store.UpdateStore{}

	if input.Name != nil {
		return nil, errors.New("Store name cannot be changed after being created")
	}
	if input.Link != nil {
		mod.Link = *input.Link
	}
	if input.Description != nil {
		mod.Description = *input.Description
	}

	if input.Address != nil {
		mod.Address = *input.Address
		mod.HasPhysicalAddress = true
	}
	if input.Wallet != nil {
		mod.Wallet = float64(*input.Wallet)
	}
	if input.Thumbnail != nil {
		mod.Thumbnail = *input.Thumbnail
	}
	if input.Phone != nil {
		mod.Phone = *input.Phone
	}

	if input.Visitor != nil {

		mod.Visitors = *input.Visitor
	}
	if input.Account != nil {
		mod.Account = &store.WithdrawalAccount{
			BankName:      input.Account.BankName,
			BankCode:      input.Account.BankCode,
			AccountNumber: input.Account.AccountNumber,
			AccountName:   input.Account.AccountName,
			BankImage:     input.Account.BankImage,
		}
	}

	if input.Email != nil {
		mod.Email = *input.Email
	}
	if input.Background != nil {
		mod.Background = *input.Background
	}
	if input.ID != nil {
		idUint64, err := strconv.ParseUint(*input.ID, 10, 32)
		if err != nil {
			fmt.Println("Error converting ID:", err)
		} else {
			mod.ID = uint32(idUint64)
		}
	}
	if input.Status != nil {
		if *input.Status == false {
			user.NewRepository().SendMaintenanceMail(ctx, strconv.Itoa(*input.User), true)
		} else if *input.Status == true {
			user.NewRepository().SendMaintenanceMail(ctx, strconv.Itoa(*input.User), false)
		}
		mod.Status = *input.Status
	}

	resp, err := storeHandler.UpdateStore(ctx, mod)
	if err != nil {
		return nil, err
	}
	modalResp := &model.Store{
		ID:                 strconv.FormatUint(uint64(resp.ID), 10),
		Name:               resp.Name,
		Link:               resp.Link,
		Description:        resp.Description,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Background:         resp.Background,
		Thumbnail:          resp.Thumbnail,
		// Email: resp.Email,
		Status: resp.Status,
	}
	for _, account := range resp.Accounts {
		modalResp.Accounts = append(modalResp.Accounts, &model.WithdrawAccount{
			BankName:      account.BankName,
			BankCode:      account.BankCode,
			AccountNumber: account.AccountNumber,
			AccountName:   account.AccountName,
			BankImage:     account.BankImage,
		})
	}
	return modalResp, nil
}

// DeleteStore is the resolver for the deleteStore field.
func (r *mutationResolver) DeleteStore(ctx context.Context, storeID int) (*model.Store, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("", token)
	if authErr != nil {
		return nil, authErr
	}
	panic(fmt.Errorf("not implemented: DeleteStore - deleteStore"))
}

// CreateDVAAccount is the resolver for the createDVAAccount field.
func (r *mutationResolver) CreateDVAAccount(ctx context.Context, input model.DVAAccountInput) (string, error) {
	// 	token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return "", authErr
	// }
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return "", fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	modelInput := user.DVADetails{
		// UserEmail:    ,
		StoreName: input.StoreName,
	}
	resp, err := userHandler.CreateDVAAccount(ctx, &modelInput)
	if err != nil {
		return "", err
	}
	return resp, nil
}

// InitializePayment is the resolver for the initializePayment field.
func (r *mutationResolver) InitializePayment(ctx context.Context, input model.PaymentData) (*string, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	paymentOrder := &store.Order{
		Amount:         *input.Amount,
		UserID:         input.UserID,
		PaymentGateway: *input.PaymentGateway,
		UUID:           *input.UUID,
		CreatedAt:      time.Now().UTC(),
		UpdatedAt:      time.Now().UTC(),
	}
	resp, err := cartHandler.InitiatePayment(ctx, paymentOrder)
	if err != nil {
		return nil, err
	}
	return &resp, err
}

// VerifySmartCard is the resolver for the verifySmartCard field.
func (r *mutationResolver) VerifySmartCard(ctx context.Context, input model.SmartCardInput) (*model.SmartcardVerificationResponse, error) {
	skynetRep := app.InitializePackage(app.SkynetPackage)

	skynetRepository, ok := skynetRep.(skynet.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("skynetRep is not a skynet.Repository")
	}
	skynetSrvc := skynet.NewService(skynetRepository)
	skynetHandler := skynet.NewHandler(skynetSrvc)
	resp, err := skynetHandler.VerifySmartCard(ctx, input.ServiceID, input.BillersCode, *input.CardType)

	if err != nil {
		return nil, err
	}

	// Map the response to the GraphQL model
	verificationResponse := &model.SmartcardVerificationResponse{
		Code: resp.Code,
		Content: &model.SmartcardContent{
			CustomerName:       resp.Content.CustomerName,
			Status:             resp.Content.Status,
			DueDate:            resp.Content.DueDate,
			CustomerNumber:     resp.Content.CustomerNumber,
			CustomerType:       resp.Content.CustomerType,
			CurrentBouquet:     resp.Content.CurrentBouquet,
			CurrentBouquetCode: resp.Content.CurrentBouquetCode,
			RenewalAmount:      resp.Content.RenewalAmount,
		},
	}

	return verificationResponse, nil
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, input model.ChatInput) (*model.Chat, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	messagesRep := app.InitializePackage(app.MessagePackage)

	messagesRepository, ok := messagesRep.(messages.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("messagesRep is not a messages.Repository")
	}
	messagesSrvc := messages.NewService(messagesRepository)
	messagesHandler := messages.NewHandler(messagesSrvc)
	var chatUsers []*user.User
	for _, usr := range input.Users {
		chatUser := &user.User{
			ID:       uint32(usr.ID),
			Fullname: usr.Name,
		}
		chatUsers = append(chatUsers, chatUser)
	}

	resp, err := messagesHandler.FindOrCreateChat(ctx, chatUsers)
	var cUsers []*model.MessageUser
	for _, cUser := range resp.Users {

		res := &model.MessageUser{
			ID:   int(cUser.ID),
			Name: cUser.Fullname,
		}
		cUsers = append(cUsers, res)
	}
	modelResponse := &model.Chat{
		Time:  resp.UpdatedAt,
		Users: cUsers,
	}
	if err != nil {
		return nil, err
	}
	return modelResponse, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.MessageInput) (*model.Message, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	messagesRep := app.InitializePackage(app.MessagePackage)

	messagesRepository, ok := messagesRep.(messages.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("messagesRep is not a messages.Repository")
	}
	messagesSrvc := messages.NewService(messagesRepository)
	messagesHandler := messages.NewHandler(messagesSrvc)
	req := &messages.Message{
		ChatID:  uint32(input.ChatID),
		Content: input.Content,
		Media:   (*messages.MediaType)(input.Media),
		IsRead:  false,
		Sender:  uint32(input.Sender),
	}

	err := messagesHandler.SendMessage(ctx, req)
	if err != nil {
		return nil, err
	}
	return convertToModelMessage(*req), nil
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input model.TransactionInput) (*model.Transaction, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("storeRep is not a cart.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)
	transaction := &store.Transactions{
		Amount:   *input.Amount,
		StoreID:  input.StoreID,
		User:     input.User,
		Type:     input.Type,
		Category: input.Category,
		Status:   input.Status,
	}
	resp, err := storeHandler.CreateTransactions(ctx, transaction)
	if err != nil {
		return nil, err
	}
	id, _ := strconv.Atoi(resp.StoreID)
	modTransaction := &model.Transaction{
		Amount:   resp.Amount,
		StoreID:  id,
		User:     resp.User,
		Type:     resp.Type,
		Category: resp.Category,
		Status:   resp.Status,
	}
	return modTransaction, nil
}

// CreateResetPasswordLink is the resolver for the createResetPasswordLink field.
func (r *mutationResolver) CreateResetPasswordLink(ctx context.Context, input model.PasswordResetInput) (bool, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return false, authErr
	// }
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return false, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)

	req := &user.PasswordReset{
		Link:  input.Link,
		Email: input.Email,
	}
	err := userHandler.SendPasswordResetLink(ctx, req)
	if err != nil {
		return false, err
	}
	return true, nil
}

// VerifyResetPasswordLink is the resolver for the verifyResetPasswordLink field.
func (r *mutationResolver) VerifyResetPasswordLink(ctx context.Context, input string) (bool, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return false, authErr
	// }
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return false, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)

	err := userHandler.VerifyResetLink(ctx, input)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdateUserPassword is the resolver for the updateUserPassword field.
func (r *mutationResolver) UpdateUserPassword(ctx context.Context, input model.PasswordUpdateInput) (bool, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("entry", token)
	// if authErr != nil {
	// 	return false, authErr
	// }
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return false, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	req := &user.PasswordReset{
		Password: input.Password,
		Email:    input.Email,
		Token:    input.Token,
	}

	err := userHandler.UpdatePassword(ctx, req)
	if err != nil {
		return false, err
	}
	return true, nil
}

// WithdrawFund is the resolver for the withdrawFund field.
func (r *mutationResolver) WithdrawFund(ctx context.Context, input model.FundInput) (bool, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return false, authErr
	}
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return false, fmt.Errorf("storeRep is not a cart.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)
	req := &store.Fund{
		StoreID:       uint32(input.StoreID),
		Amount:        float32(input.Amount),
		UserID:        uint32(input.UserID),
		Email:         input.Email,
		AccountNumber: input.AccountNumber,
		BankCode:      input.BankCode,
	}
	err := storeHandler.WithdrawFund(ctx, req)
	if err != nil {
		return false, err
	}
	return true, nil
}

// ConfirmPassword is the resolver for the confirmPassword field.
func (r *mutationResolver) ConfirmPassword(ctx context.Context, input *model.ConfirmPasswordInput) (bool, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return false, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	err := userHandler.ConfirmPassword(ctx, input.Password, input.UserID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateInvoice is the resolver for the createInvoice field.
func (r *mutationResolver) CreateInvoice(ctx context.Context, input model.InvoiceInput) (*model.Invoice, error) {
	// Extract the token from the context
	token := ctx.Value("token").(string)

	// Authenticate the user
	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}

	// Initialize store repository and service
	storeRep := app.InitializePackage(app.StorePackage)
	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		return nil, fmt.Errorf("storeRep is not a store.Repository")
	}

	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	// Map the input data to the store model (Invoice)
	mod := &store.Invoice{
		Customer: &store.InvoiceCustomer{
			Email:  input.Customer.Email,
			Name:   input.Customer.Name,
			Number: input.Customer.Number,
		},
		DueDate: input.DueDate,
		DeliveryDetails: &store.InvoiceDelivery{
			Option:  input.DeliveryDetails.Option,
			Address: input.DeliveryDetails.Address,
			Fee:     input.DeliveryDetails.Price,
		},
		StoreID: uint32(input.StoreID),
	}

	// Convert the items from the input to the InvoiceItem model
	var invoiceItems []*store.InvoiceItem
	for _, item := range input.Items {
		prd := &store.InvoiceItem{
			Quantity: int32(item.Quantity),
			Price:    item.Price,
			Name:     item.Name,
		}
		invoiceItems = append(invoiceItems, prd)
	}
	mod.Items = invoiceItems

	// Create the invoice using the storeHandler
	resp, err := storeHandler.CreateInvoice(ctx, mod)
	if err != nil {
		return nil, err
	}

	// Return the created invoice (you might need to map the response back to the model)
	return mapStoreInvoiceToModelInvoice(resp), nil
}

// Users is the resolver for the Users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	resp, err := userHandler.GetUsers(ctx)
	if err != nil {
		return nil, err
	}

	var users []*model.User
	var followedStores []*model.Store

	// Assuming resp is a slice of users
	for _, item := range resp {
		accessToken := item.AccessToken
		refreshToken := item.RefreshToken
		paymentDetails := &model.PaymentDetails{
			Name:    item.PaymentDetails.Name,
			Address: item.PaymentDetails.Address,
			Phone:   item.PaymentDetails.Phone,
			Info:    item.PaymentDetails.Info,
		}
		user := &model.User{
			ID:           strconv.FormatInt(int64(item.ID), 10),
			Fullname:     item.Fullname,
			Campus:       item.Campus,
			Email:        item.Email,
			Phone:        item.Phone,
			Twofa:        *item.Twofa,
			Active:       *item.Active,
			AccessToken:  &accessToken,
			RefreshToken: &refreshToken,
			Usertype:     item.Usertype,
			Code:         item.Code,
			Online:       item.Online,
			Avatar:       &item.Avatar,
			Dob:          &item.Dob,
			// Codeexpiry: item.Codeexpiry.Format(time.RFC3339),

			Password:       "lol......what do y'need it for?",
			PaymnetDetails: paymentDetails,
			UUID:           item.UUID,
		}
		for _, store := range item.FollowedStores {
			followedStore := &model.Store{
				Name:        store.Name,
				Description: store.Description,
				Background:  store.Background,
				Thumbnail:   store.Thumbnail,
				Link:        store.Link,
			}
			user.Stores = append(followedStores, followedStore)
		}
		users = append(users, user)
	}

	return users, nil
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	resp, err := userHandler.GetUser(ctx, id)
	if err != nil {
		return nil, err
	}
	accessToken := resp.AccessToken
	refreshToken := resp.RefreshToken
	paymentDetails := &model.PaymentDetails{
		Name:    resp.PaymentDetails.Name,
		Address: resp.PaymentDetails.Address,
		Phone:   resp.PaymentDetails.Phone,
		Info:    resp.PaymentDetails.Info,
	}

	user := &model.User{
		ID:             strconv.FormatInt(int64(resp.ID), 10),
		Fullname:       resp.Fullname,
		Campus:         resp.Campus,
		Email:          resp.Email,
		Phone:          resp.Phone,
		Twofa:          *resp.Twofa,
		Active:         *resp.Active,
		AccessToken:    &accessToken,
		RefreshToken:   &refreshToken,
		Online:         resp.Online,
		Dob:            &resp.Dob,
		Usertype:       resp.Usertype,
		Code:           resp.Code,
		Avatar:         &resp.Avatar,
		UUID:           resp.UUID,
		PaymnetDetails: paymentDetails,
		Password:       "lol......what do y'need it for?",
	}
	for _, store := range resp.FollowedStores {
		followedStore := &model.Store{
			Name:        store.Name,
			Description: store.Description,
			Thumbnail:   store.Thumbnail,
			Background:  store.Background,
			Link:        store.Link,
		}
		user.Stores = append(user.Stores, followedStore)
	}

	return user, nil
}

// Categories is the resolver for the Categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetCategories(ctx)
	if err != nil {
		return nil, err
	}

	var categories []*model.Category

	// Assuming resp is a slice of categories
	for _, item := range resp {
		var subCategories []*model.SubCategory

		for _, subItem := range item.SubCategories {
			subCategory := &model.SubCategory{
				Name:     subItem.Name,
				Slug:     subItem.Slug,
				Category: int(subItem.CategoryID),
			}
			subCategories = append(subCategories, subCategory)
		}

		category := &model.Category{
			Name:          item.Name,
			Slug:          item.Slug,
			Subcategories: subCategories,
			ID:            strconv.Itoa(item.ID),
		}
		categories = append(categories, category)
	}
	return categories, nil
}

// Category is the resolver for the Category field.
func (r *queryResolver) Category(ctx context.Context, id int) (*model.Category, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetCategory(ctx, uint32(id))
	if err != nil {
		return nil, err
	}

	var category *model.Category
	var subCategories []*model.SubCategory
	for _, subItem := range resp.SubCategories {
		subCategory := &model.SubCategory{
			Name:     subItem.Name,
			Slug:     subItem.Slug,
			Category: int(subItem.CategoryID),
		}
		subCategories = append(subCategories, subCategory)
	}
	category = &model.Category{
		Name:          resp.Name,
		Slug:          resp.Slug,
		Subcategories: subCategories,
		ID:            strconv.Itoa(resp.ID),
	}
	return category, nil
}

// SubCategory is the resolver for the SubCategory field.
func (r *queryResolver) SubCategory(ctx context.Context, id string) (*model.SubCategory, error) {
	panic(fmt.Errorf("not implemented: SubCategory - SubCategory"))
}

// Products is the resolver for the Products field.
func (r *queryResolver) Products(ctx context.Context, store *string, limit *int, offset *int) (*model.ProductPaginationData, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)

	resp, count, err := productHandler.GetProducts(ctx, *store, *limit, *offset)
	if err != nil {
		return nil, err
	}

	var products []*model.Product

	// Assuming resp is a slice of products
	for _, item := range resp {
		id, _ := strconv.Atoi(strconv.FormatInt(int64(item.ID), 10))
		product := &model.Product{
			ID:              id,
			Name:            item.Name,
			Description:     item.Description,
			Image:           item.Images,
			Price:           item.Price,
			Status:          item.Status,
			Quantity:        item.Quantity,
			Slug:            item.Slug,
			Store:           item.Store,
			Thumbnail:       item.Thumbnail,
			Category:        item.Category,
			Subcategory:     item.Subcategory,
			File:            &item.File,
			Type:            item.Type,
			AlwaysAvailable: item.AlwaysAvailbale,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
				productVariant := &model.Variant{}
				productVariant.Name = outerItem.Name
				variantValues := make([]*model.VariantValue, 0)

				for _, item := range outerItem.Value {
					modelVariantValue := &model.VariantValue{
						Value:  item.Value,
						Price:  item.Price,
						Images: item.Images,
					}
					variantValues = append(variantValues, modelVariantValue)
				}
				productVariant.Value = variantValues
				product.Variant = append(product.Variant, productVariant)
			}
		}

		if len(item.Reviews) != 0 {
			for _, review := range item.Reviews {
				modelReview := &model.Review{
					Rating:    review.Rating,
					Message:   review.Message,
					Image:     review.Image,
					ProductID: int(review.ProductID), //to be reviewed later
					ID:        &review.ID,
					Username:  review.Username,
				}
				product.Review = append(product.Review, modelReview)
			}
		}
		products = append(products, product)
	}
	currentPage := *offset + 1
	totalPages := int(math.Ceil(float64(count) / float64(*limit)))

	nextPage := 0
	if currentPage < totalPages {
		nextPage = currentPage + 1
	}
	prevPage := 0
	if currentPage > 1 {
		prevPage = currentPage - 1
	}

	payload := &model.ProductPaginationData{
		Data:        products,
		CurrentPage: currentPage,
		PerPage:     *limit,
		Total:       count,
		NextPage:    nextPage,
		PrevPage:    prevPage,
	}

	return payload, nil
}

// Product is the resolver for the Product field.
func (r *queryResolver) Product(ctx context.Context, id int) (*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetProduct(ctx, uint32(id), 0)
	if err != nil {
		return nil, err
	}

	product := &model.Product{
		ID:              int(resp.ID),
		Name:            resp.Name,
		Description:     resp.Description,
		Image:           resp.Images,
		Price:           resp.Price,
		Status:          resp.Status,
		Quantity:        resp.Quantity,
		Slug:            resp.Slug,
		Store:           resp.Store,
		Category:        resp.Category,
		Subcategory:     resp.Subcategory,
		File:            &resp.File,
		Type:            resp.Type,
		AlwaysAvailable: resp.AlwaysAvailbale,
		Thumbnail:       resp.Thumbnail,
	}
	if len(resp.Variant) != 0 {
		for _, outerItem := range resp.Variant {
			productVariant := &model.Variant{}
			productVariant.Name = outerItem.Name
			variantValues := make([]*model.VariantValue, 0)

			for _, item := range outerItem.Value {
				modelVariantValue := &model.VariantValue{
					Value:  item.Value,
					Price:  item.Price,
					Images: item.Images,
				}
				variantValues = append(variantValues, modelVariantValue)
			}
			productVariant.Value = variantValues
			product.Variant = append(product.Variant, productVariant)
		}
	}

	if len(resp.Reviews) != 0 {
		for _, review := range resp.Reviews {
			modelReview := &model.Review{
				Rating:    review.Rating,
				Message:   review.Message,
				Image:     review.Image,
				ProductID: int(review.ProductID), //to be reviewed later
				ID:        &review.ID,
				Username:  review.Username,
			}
			product.Review = append(product.Review, modelReview)
		}
	}

	return product, nil
}

// HandledProducts is the resolver for the HandledProducts field.
func (r *queryResolver) HandledProducts(ctx context.Context, user int, typeArg string) ([]*model.HandledProducts, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {

		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetHandledProducts(ctx, uint32(user), typeArg)
	if err != nil {
		return nil, err
	}
	prds := []*model.HandledProducts{}
	for i, item := range resp {
		// fmt.Println(item.Product)
		prd := &model.HandledProducts{
			ProductID:        int(item.ID),
			ProductName:      &item.Product.Name,
			ProductDiscount:  &item.Product.Discount,
			ProductPrice:     &item.Product.Price,
			ProductThumbnail: &item.Product.Thumbnail,
			ProductQuantity:  &item.Product.Quantity,
			ProductStatus:    &item.Product.Status,
			UserID:           int(resp[i].UserID),
		}
		prds = append(prds, prd)
	}
	return prds, nil
}

// RecommendedProducts is the resolver for the RecommendedProducts field.
func (r *queryResolver) RecommendedProducts(ctx context.Context, query string) ([]*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetRecommendedProducts(ctx, query)
	if err != nil {
		return nil, err
	}
	var products []*model.Product

	for _, item := range resp {
		product := &model.Product{
			// ID:       strconv.FormatInt(int64(item.ID), 10),
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Images,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			// Variant:     item.Variant,
			Store:       item.Store,
			Category:    item.Category,
			Subcategory: item.Subcategory,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
				productVariant := &model.Variant{}
				productVariant.Name = outerItem.Name
				variantValues := make([]*model.VariantValue, 0)

				for _, item := range outerItem.Value {
					modelVariantValue := &model.VariantValue{
						Value:  item.Value,
						Price:  item.Price,
						Images: item.Images,
					}
					variantValues = append(variantValues, modelVariantValue)
				}
				productVariant.Value = variantValues
				product.Variant = append(product.Variant, productVariant)

			}
		}
		products = append(products, product)
	}
	return products, nil
}

// RecentlyAddedProducts is the resolver for the RecentlyAddedProducts field.
func (r *queryResolver) RecentlyAddedProducts(ctx context.Context, user int) ([]*model.Product, error) {
	panic(fmt.Errorf("not implemented: RecentlyAddedProducts - RecentlyAddedProducts"))
}

// ProductReviews is the resolver for the ProductReviews field.
func (r *queryResolver) ProductReviews(ctx context.Context, id int, sellerStore string) ([]*model.Review, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetProductReviews(ctx, uint32(id), sellerStore)
	if err != nil {
		return nil, err
	}
	var reviews []*model.Review
	for _, item := range resp {
		review := &model.Review{
			Username:  item.Username,
			Image:     item.Image,
			Message:   item.Message,
			Rating:    item.Rating,
			ProductID: int(item.ProductID),
		}
		reviews = append(reviews, review)
	}
	return reviews, nil
}

// Cart is the resolver for the Cart field.
func (r *queryResolver) Cart(ctx context.Context, user int) (*model.Cart, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	cartRep := app.InitializePackage(app.CartPackage)
	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		panic("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	resp, err := cartHandler.GetCart(ctx, uint32(user))
	if err != nil {
		return nil, err
	}
	var modelCartItems []*model.CartItem

	for _, item := range resp.Items {
		modelProduct := &model.Product{
			ID:          int(item.Product.ID),
			Quantity:    item.Product.Quantity,
			Name:        item.Product.Name,
			Description: item.Product.Description,
			Price:       item.Product.Price,
			Thumbnail:   item.Product.Thumbnail,
			Image:       item.Product.Images,
			Discount:    item.Product.Discount,
			Category:    item.Product.Category,
			Status:      item.Product.Status,
			Store:       item.Product.Store,
		}
		if len(item.Product.Variant) != 0 {
			for _, outerItem := range item.Product.Variant {
				productVariant := &model.Variant{}
				productVariant.Name = outerItem.Name
				variantValues := make([]*model.VariantValue, 0)

				for _, item := range outerItem.Value {
					modelVariantValue := &model.VariantValue{
						Value:  item.Value,
						Price:  item.Price,
						Images: item.Images,
					}
					variantValues = append(variantValues, modelVariantValue)
				}
				productVariant.Value = variantValues
				modelProduct.Variant = append(modelProduct.Variant, productVariant)

			}
		}
		modelItem := &model.CartItem{
			Product:  modelProduct,
			Quantity: int(item.Quantity),
		}
		modelCartItems = append(modelCartItems, modelItem)
	}

	// var items []*model.CartItem
	cart := &model.Cart{
		Total:  resp.Total,
		Items:  modelCartItems,
		Active: resp.Active,
		ID:     uint32ToStringPtr(resp.ID),
		User:   int(resp.UserID),
	}
	return cart, nil
}

// SubscriptionBundle is the resolver for the SubscriptionBundle field.
func (r *queryResolver) SubscriptionBundle(ctx context.Context, serviceID string) (*model.SubscriptionBundle, error) {
	skynetRep := app.InitializePackage(app.SkynetPackage)

	skynetRepository, ok := skynetRep.(skynet.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("skynetRep is not a skynet.Repository")
	}
	skynetSrvc := skynet.NewService(skynetRepository)
	skynetHandler := skynet.NewHandler(skynetSrvc)
	resp, err := skynetHandler.GetSubscriptionsBundles(ctx, serviceID)
	if err != nil {
		return nil, err
	}
	var variations []*model.BundleVariation
	for _, v := range resp.Variations {
		variation := &model.BundleVariation{
			VariationCode:   v.VariationCode,
			Name:            v.Name,
			VariationAmount: v.VariationAmount,
			FixedPrice:      v.FixedPrice,
		}
		variations = append(variations, variation)
	}

	response := &model.SubscriptionBundle{
		ServiceName:    resp.ServiceName,
		ServiceID:      resp.ServiceID,
		ConvinienceFee: resp.ConvinienceFee,
		Variations:     variations,
	}

	return response, nil
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, query string) ([]*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.SearchProducts(ctx, query)
	if err != nil {
		return nil, err
	}
	var products []*model.Product

	for _, item := range resp {
		product := &model.Product{
			ID:          int(int64(item.ID)),
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Images,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			Store:       item.Store,
			Category:    item.Category,
			Subcategory: item.Subcategory,
			Thumbnail:   item.Thumbnail,
		}
		if len(item.Variant) != 0 {
			for _, outerItem := range item.Variant {
				productVariant := &model.Variant{}
				productVariant.Name = outerItem.Name
				variantValues := make([]*model.VariantValue, 0)

				for _, item := range outerItem.Value {
					modelVariantValue := &model.VariantValue{
						Value:  item.Value,
						Price:  item.Price,
						Images: item.Images,
					}
					variantValues = append(variantValues, modelVariantValue)
				}
				productVariant.Value = variantValues
				product.Variant = append(product.Variant, productVariant)

			}
		}
		if len(item.Reviews) != 0 {
			for _, review := range item.Reviews {
				modelReview := &model.Review{
					Rating:    review.Rating,
					Message:   review.Message,
					Image:     review.Image,
					ProductID: int(review.ProductID), //to be reviewed later
					ID:        &review.ID,
					Username:  review.Username,
				}
				product.Review = append(product.Review, modelReview)
			}
		}
		products = append(products, product)
	}
	return products, nil
}

// Stores is the resolver for the Stores field.
func (r *queryResolver) Stores(ctx context.Context, user *int, limit *int, offset *int) (*model.StorePaginationData, error) {
	// token := ctx.Value("token").(string)

	// authErr := middlewares.AuthMiddleware("seller", token)
	// if authErr != nil {
	// 	return nil, authErr
	// }
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)
	resp, err := storeHandler.GetStores(ctx, uint32(*user), *limit, *offset)
	if err != nil {
		return nil, err
	}

	var stores []*model.Store
	for _, item := range resp {
		id, _ := strconv.Atoi(strconv.FormatInt(int64(item.ID), 10))

		store := &model.Store{
			ID:                 strconv.Itoa(id),
			Name:               item.Name,
			HasPhysicalAddress: item.HasPhysicalAddress,
			Link:               item.Link,
			Wallet:             item.Wallet,
			User:               int(item.UserID),
			Description:        item.Description,
			Thumbnail:          item.Thumbnail,
			Background:         item.Background,
			Phone:              item.Phone,
			Address:            item.Address,
			Email:              item.Email,
			Visitors:           item.Visitors,
			Status:             item.Status,
		}

		// Map followers
		if len(item.Followers) > 0 {
			for _, follower := range item.Followers {
				storeFollower := &model.StoreFollower{
					FollowerID:    int(follower.FollowerID),
					FollowerName:  follower.FollowerName,
					FollowerImage: follower.FollowerImage,
					StoreID:       int(follower.StoreID),
				}
				store.Followers = append(store.Followers, storeFollower)
			}
		}

		// Map transactions
		if len(item.Transactions) > 0 {
			for _, transaction := range item.Transactions {
				storeTransactions := &model.Transaction{
					StoreID:   convertStringToInt(transaction.StoreID),
					User:      transaction.User,
					Amount:    transaction.Amount,
					Type:      transaction.Type,
					Category:  transaction.Category,
					Status:    transaction.Status,
					CreatedAt: transaction.CreatedAt,
					UUID:      transaction.UUID,
				}
				store.Transactions = append(store.Transactions, storeTransactions)
			}
		}

		// Map Withradrawal account
		if len(item.Accounts) > 0 {
			for _, account := range item.Accounts {
				storeAccount := &model.WithdrawAccount{
					BankCode:      account.BankCode,
					BankName:      account.BankName,
					AccountNumber: account.AccountNumber,
					AccountName:   account.AccountName,
					BankImage:     account.BankImage,
				}
				store.Accounts = append(store.Accounts, storeAccount)
			}
		}

		// Map orders
		if len(item.Orders) > 0 {
			for _, order := range item.Orders {
				storeOrder := &model.StoreOrder{
					Status: order.Status,
					Customer: &model.StoreCustomer{
						Name:    order.Customer.Name,
						Address: order.Customer.Address,
						Phone:   order.Customer.Phone,
					},
					Active:    order.Active,
					TrtRef:    order.UUID,
					CreatedAt: order.CreatedAt,
					UUID:      order.UUID,
					StoreID:   order.StoreID,
				}

				// Map products within orders
				var products []*model.Product
				for _, p := range order.Products {
					product := &model.Product{
						ID:        int(p.ID), // Make sure this ID is correctly mapped
						Name:      p.Name,
						Quantity:  p.Quantity,
						Price:     p.Price,
						Thumbnail: p.Thumbnail,
						// Store:     p.Store,
					}
					products = append(products, product)
				}

				storeOrder.Product = products
				store.Orders = append(store.Orders, storeOrder)
			}
		}

		stores = append(stores, store)
	}

	payload := &model.StorePaginationData{
		Data:        stores,
		CurrentPage: *offset + 1,
		PerPage:     *limit,
		Total:       len(resp),
	}
	return payload, nil
}

// Store is the resolver for the Store field.
func (r *queryResolver) Store(ctx context.Context, id int) (*model.Store, error) {
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	resp, err := storeHandler.GetStore(ctx, uint32(id))

	if err != nil {
		return nil, err
	}
	storeId, _ := strconv.Atoi(strconv.FormatInt(int64(resp.ID), 10))

	store := &model.Store{
		ID:                 strconv.Itoa(storeId),
		Name:               resp.Name,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Link:               resp.Link,
		Wallet:             resp.Wallet,
		User:               int(resp.UserID),
		Description:        resp.Description,
		Thumbnail:          resp.Thumbnail,
		Background:         resp.Background,
		Address:            resp.Address,
		Phone:              resp.Phone,
		Visitors:           resp.Visitors,
		Status:             resp.Status,
	}

	for _, follower := range resp.Followers {
		storeFollower := &model.StoreFollower{}
		storeFollower.FollowerID = int(follower.FollowerID)
		storeFollower.FollowerName = follower.FollowerName
		storeFollower.FollowerImage = follower.FollowerImage
		storeFollower.StoreID = int(follower.StoreID)

		store.Followers = append(store.Followers, storeFollower)
	}

	for _, transaction := range store.Transactions {
		storeTransactions := &model.Transaction{
			StoreID:   transaction.StoreID,
			User:      transaction.User,
			Amount:    transaction.Amount,
			Type:      transaction.Type,
			Category:  transaction.Category,
			Status:    transaction.Status,
			CreatedAt: transaction.CreatedAt,
			UUID:      transaction.UUID,
		}
		store.Transactions = append(store.Transactions, storeTransactions)
	}

	// Map Withradrawal account
	if len(store.Accounts) > 0 {
		for _, account := range store.Accounts {
			storeAccount := &model.WithdrawAccount{
				BankCode:      account.BankCode,
				BankName:      account.BankName,
				AccountNumber: account.AccountNumber,
				AccountName:   account.AccountName,
				BankImage:     account.BankImage,
			}
			store.Accounts = append(store.Accounts, storeAccount)
		}
	}

	for _, order := range store.Orders {
		storeOrder := &model.StoreOrder{
			Status: order.Status,
			Customer: &model.StoreCustomer{
				Name:    order.Customer.Name,
				Address: order.Customer.Address,
				Phone:   order.Customer.Phone,
			},
			Active:    order.Active,
			TrtRef:    order.TrtRef,
			CreatedAt: order.CreatedAt,
			UUID:      order.UUID,
			StoreID:   order.StoreID,
		}

		// Map products within orders
		var products []*model.Product
		for _, p := range order.Product {
			product := &model.Product{
				ID:        int(p.ID), // Make sure this ID is correctly mapped
				Name:      p.Name,
				Quantity:  p.Quantity,
				Price:     p.Price,
				Thumbnail: p.Thumbnail,
			}
			products = append(products, product)
		}

		storeOrder.Product = products
		store.Orders = append(store.Orders, storeOrder)
	}

	return store, nil
}

// StoreByName is the resolver for the StoreByName field.
func (r *queryResolver) StoreByName(ctx context.Context, name string) (*model.Store, error) {
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	resp, err := storeHandler.GetStoreByName(ctx, name)

	if err != nil {
		return nil, err
	}
	storeId, _ := strconv.Atoi(strconv.FormatInt(int64(resp.ID), 10))

	store := &model.Store{
		ID:                 strconv.Itoa(storeId),
		Name:               resp.Name,
		HasPhysicalAddress: resp.HasPhysicalAddress,
		Link:               resp.Link,
		Wallet:             resp.Wallet,
		User:               int(resp.UserID),
		Description:        resp.Description,
		Thumbnail:          resp.Thumbnail,
		Background:         resp.Background,
		Address:            resp.Address,
		Phone:              resp.Phone,
		Status:             resp.Status,
		Visitors:           resp.Visitors,
	}
	for _, follower := range resp.Followers {
		storeFollower := &model.StoreFollower{}
		storeFollower.FollowerID = int(follower.FollowerID)
		storeFollower.FollowerName = follower.FollowerName
		storeFollower.FollowerImage = follower.FollowerImage
		storeFollower.StoreID = int(follower.StoreID)

		store.Followers = append(store.Followers, storeFollower)
	}

	for _, order := range store.Orders {
		storeOrder := &model.StoreOrder{
			Status: order.Status,
			Customer: &model.StoreCustomer{
				Name:    order.Customer.Name,
				Address: order.Customer.Address,
				Phone:   order.Customer.Phone,
			},
			Active:    order.Active,
			TrtRef:    order.TrtRef,
			CreatedAt: order.CreatedAt,
			UUID:      order.UUID,
			StoreID:   order.StoreID,
		}

		// Map products within orders
		var products []*model.Product
		for _, p := range order.Product {
			product := &model.Product{
				ID:        int(p.ID), // Make sure this ID is correctly mapped
				Name:      p.Name,
				Quantity:  p.Quantity,
				Price:     p.Price,
				Thumbnail: p.Thumbnail,
			}
			products = append(products, product)
		}

		storeOrder.Product = products
		store.Orders = append(store.Orders, storeOrder)
	}

	// Map Withradrawal account
	if len(store.Accounts) > 0 {
		for _, account := range store.Accounts {
			storeAccount := &model.WithdrawAccount{
				BankCode:      account.BankCode,
				BankName:      account.BankName,
				AccountNumber: account.AccountNumber,
				AccountName:   account.AccountName,
				BankImage:     account.BankImage,
			}
			store.Accounts = append(store.Accounts, storeAccount)
		}
	}

	for _, transaction := range store.Transactions {
		storeTransactions := &model.Transaction{
			StoreID:   transaction.StoreID,
			User:      transaction.User,
			Amount:    transaction.Amount,
			Type:      transaction.Type,
			Category:  transaction.Category,
			Status:    transaction.Status,
			CreatedAt: transaction.CreatedAt,
			UUID:      transaction.UUID,
		}
		store.Transactions = append(store.Transactions, storeTransactions)
	}

	return store, nil
}

// PurchasedOrder is the resolver for the PurchasedOrder field.
func (r *queryResolver) PurchasedOrder(ctx context.Context, user int) ([]*model.PurchasedOrder, error) {
	storeRep := app.InitializePackage(app.StorePackage)

	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)
	resp, err := storeHandler.GetPurchasedOrders(ctx, strconv.FormatInt(int64(user), 10))
	if err != nil {
		return nil, err
	}
	purchasedOrders := []*model.PurchasedOrder{}

	for _, order := range resp {
		purchasedOrder := &model.PurchasedOrder{}

		purchasedOrder.CartID = int(order.CartID)
		purchasedOrder.UUID = order.UUID
		purchasedOrder.Fee = order.Fee
		purchasedOrder.Amount = order.Amount
		purchasedOrder.PaymentGateway = order.PaymentGateway
		purchasedOrder.PaymentMethod = order.PaymentMethod
		// purchasedOrder.Cre = order.CreatedAt
		purchasedOrder.TransRef = order.TransRef
		purchasedOrder.TransStatus = order.TransStatus
		purchasedOrder.Products = convertToModelTrackedProducts(order.Products)
		purchasedOrder.Status = order.Status
		purchasedOrder.DeliveryDetails = &model.DeliveryDetails{
			Fee:     order.DeliveryDetails.Fee,
			Method:  order.DeliveryDetails.Method,
			Address: order.DeliveryDetails.Address,
		}
		purchasedOrders = append(purchasedOrders, purchasedOrder)
	}
	return purchasedOrders, nil
}

// Skynets is the resolver for the Skynets field.
func (r *queryResolver) Skynets(ctx context.Context, id string) ([]*model.Skynet, error) {
	panic(fmt.Errorf("not implemented: Skynets - Skynets"))
}

// Skynet is the resolver for the Skynet field.
func (r *queryResolver) Skynet(ctx context.Context, id string) (*model.Skynet, error) {
	panic(fmt.Errorf("not implemented: Skynet - Skynet"))
}

// Mydva is the resolver for the MYDVA field.
func (r *queryResolver) Mydva(ctx context.Context, email string) (*model.Account, error) {
	userRep := app.InitializePackage(app.UserPackage)

	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	res, err := userHandler.GetMyDVA(ctx, email)

	// fmt.Print(res)
	if err != nil {
		return nil, err
	}
	accntNum, _ := strconv.Atoi(res.AccountNumber)
	account := &model.Account{
		ID:            res.ID,
		AccountNumber: accntNum,
		AccountName:   res.AccountName,
		CreatedAt:     res.CreatedAt,
		UpdatedAt:     res.UpdatedAt,
		Active:        res.Active,
		Assigned:      res.Assigned,
		Customer: &model.Customer{
			ID:           res.Customer.ID,
			FirstName:    res.Customer.FirstName,
			LastName:     res.Customer.LastName,
			Email:        res.Customer.Email,
			CustomerCode: res.Customer.CustomerCode,
			Phone:        res.Customer.Phone,
			RiskAction:   res.Customer.RiskAction,
		},
		Bank: &model.Bank{
			Name: res.Bank.Name,
			ID:   res.Bank.ID,
			Slug: res.Bank.Slug,
		},
		SplitConfig: &model.SplitConfig{
			Subaccount: res.SplitConfig.Subaccount,
		},
	}

	return account, nil
}

// Chats is the resolver for the Chats field.
func (r *queryResolver) Chats(ctx context.Context, userID string) ([]*model.Chat, error) {
	messageRep := app.InitializePackage(app.MessagePackage)

	messageRepository, ok := messageRep.(messages.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("messageRep is not a messages.Repository")
	}
	messagesSrvc := messages.NewService(messageRepository)
	id, _ := strconv.ParseUint(userID, 10, 32)
	messagesHandler := messages.NewHandler(messagesSrvc)
	chats, err := messagesHandler.GetChatLists(ctx, uint32(id))
	if err != nil {
		return nil, err
	}

	var resp []*model.Chat
	for _, chat := range chats {
		// Convert []uint32 to []*int
		var users []*model.MessageUser
		for _, user := range chat.Users {
			r := &model.MessageUser{
				ID:     int(user.ID),
				Name:   user.Fullname,
				Avatar: &user.Avatar,
			}
			users = append(users, r)
		}
		var messages []*model.Message
		chatID := int(chat.ID)
		for _, message := range chat.Messages {
			msg := &model.Message{
				ID:        int(message.ID),
				ChatID:    int(message.ChatID),
				Content:   message.Content,
				Sender:    int(message.Sender),
				Users:     users,
				CreatedAt: &message.CreatedAt,
				UpdatedAt: &message.UpdatedAt,
			}
			messages = append(messages, msg)
		}
		latestMessage := convertToModelMessage(chat.LatestMessage)

		newChat := &model.Chat{
			ID:            &chatID,
			LatestMessage: latestMessage,
			Messages:      messages,
			UnreadCount:   chat.UnreadCount,
			Users:         users,
			Time:          chat.UpdatedAt,
		}

		resp = append(resp, newChat)
	}
	return resp, nil
}

// Messages is the resolver for the Messages field.
func (r *queryResolver) Messages(ctx context.Context, chatID string) ([]*model.Message, error) {
	panic(fmt.Errorf("not implemented: Messages - Messages"))
}

// GetDVABalance is the resolver for the GetDVABalance field.
func (r *queryResolver) GetDVABalance(ctx context.Context, id string) (*string, error) {
	userRep := app.InitializePackage(app.UserPackage)

	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	err := userHandler.GetBalance(ctx, id)
	if err != nil {
		return nil, err
	}
	return nil, nil
}

// MyInvoices is the resolver for the MyInvoices field.
func (r *queryResolver) MyInvoices(ctx context.Context, storeID *int) ([]*model.Invoice, error) {
	// Extract the token from the context for authentication
	token := ctx.Value("token").(string)

	// Authenticate the user (assuming you want to check if the user has rights to view invoices)
	authErr := middlewares.AuthMiddleware("seller", token)
	if authErr != nil {
		return nil, authErr
	}

	// Initialize the store repository
	storeRep := app.InitializePackage(app.StorePackage)
	storeRepository, ok := storeRep.(store.Repository)
	if !ok {
		return nil, fmt.Errorf("storeRep is not a store.Repository")
	}

	storeSrvc := store.NewService(storeRepository)
	storeHandler := store.NewHandler(storeSrvc)

	// Declare a variable to hold the invoices
	var invoices []*store.Invoice

	// Fetch invoices either by storeID or all invoices if storeID is nil
	var err error
	invoices, err = storeHandler.GetInvoices(ctx, uint32(*storeID))

	// Handle any errors that occurred during the fetch
	if err != nil {
		return nil, fmt.Errorf("could not fetch invoices: %v", err)
	}

	// Map the store invoices to the GraphQL model
	var modelInvoices []*model.Invoice
	for _, invoice := range invoices {
		modelInvoices = append(modelInvoices, mapStoreInvoiceToModelInvoice(invoice))
	}

	// Return the mapped invoices
	return modelInvoices, nil
}

// MyDownloads is the resolver for the MyDownloads field.
func (r *queryResolver) MyDownloads(ctx context.Context, id string) ([]*model.Downloads, error) {
	token := ctx.Value("token").(string)

	authErr := middlewares.AuthMiddleware("entry", token)
	if authErr != nil {
		return nil, authErr
	}
	userRep := app.InitializePackage(app.UserPackage)

	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	downloads, err := userHandler.GetMyDownloads(ctx, id)
	if err != nil {
		return nil, err
	}
	res := []*model.Downloads{}
	for _, download := range downloads {
		res = append(res, &model.Downloads{
			ID:        download.ID,
			Thumbnail: download.Thumbnail,
			Price:     download.Price,
			Discount:  download.Discount,
			CreatedAt: &download.CreatedAt,
			UpdatedAt: &download.UpdatedAt,
			File:      download.File,
			UUID:      download.UUID,
			Name:      download.Name,
		})
	}
	return res, nil
}

// ProductSearchResults is the resolver for the productSearchResults field.
func (r *subscriptionResolver) ProductSearchResults(ctx context.Context, query string) (<-chan []*model.Product, error) {
	panic(fmt.Errorf("not implemented: ProductSearchResults - productSearchResults"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

func mapStoreInvoiceToModelInvoice(storeInvoice *store.Invoice) *model.Invoice {
	modelInvoice := &model.Invoice{
		Customer: &model.InvoiceCustomer{
			Email:  storeInvoice.Customer.Email,
			Name:   storeInvoice.Customer.Name,
			Number: storeInvoice.Customer.Number,
		},
		DueDate: storeInvoice.DueDate,
		DeliveryDetails: &model.InvoiceDelivery{
			Option:  storeInvoice.DeliveryDetails.Option,
			Address: storeInvoice.DeliveryDetails.Address,
			Price:   storeInvoice.DeliveryDetails.Fee,
		},
		StoreID: int(storeInvoice.StoreID),
		Items:   make([]*model.InvoiceItem, len(storeInvoice.Items)),
	}

	// Map InvoiceItems
	for i, item := range storeInvoice.Items {
		modelInvoice.Items[i] = &model.InvoiceItem{
			Quantity: int(item.Quantity),
			Name:     item.Name,
			Price:    item.Price,
		}
	}

	return modelInvoice
}
func convertStringToInt(val string) int {
	i, err := strconv.Atoi(val)
	if err != nil {
		return 0
	}
	return i
}
func convertToModelTrackedProducts(products []store.TrackedProduct) []*model.TrackedProduct {
	modelProducts := make([]*model.TrackedProduct, len(products))
	for i, p := range products {
		modelProducts[i] = &model.TrackedProduct{
			ID:        int(p.ID),
			Name:      p.Name,
			Thumbnail: p.Thumbnail,
			Price:     p.Price,
			Discount:  p.Discount,
			Status:    p.Status,
		}
	}
	return modelProducts
}
func convertToModelMessage(msg messages.Message) *model.Message {
	var users []*model.MessageUser
	for _, user := range msg.Users {
		users = append(users, convertToModelUser(user))
	}
	return &model.Message{
		ID:        int(msg.ID),
		ChatID:    int(msg.ChatID),
		Content:   msg.Content,
		Sender:    int(msg.Sender),
		CreatedAt: &msg.CreatedAt,
		UpdatedAt: &msg.UpdatedAt,
		Users:     users,
		IsRead:    msg.IsRead,
	}
}
func convertToModelUser(msgUser *user.User) *model.MessageUser {
	return &model.MessageUser{
		ID:     int(msgUser.ID),
		Name:   msgUser.Fullname,
		Avatar: &msgUser.Avatar,
	}
}
func uint32ToStringPtr(value uint32) *string {
	strValue := strconv.FormatUint(uint64(value), 10)
	return &strValue
}
