package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/samstringzz/alutamarket-backend/database"
	"github.com/samstringzz/alutamarket-backend/graph/model"
	"github.com/samstringzz/alutamarket-backend/internals/cart"
	"github.com/samstringzz/alutamarket-backend/internals/messages"
	"github.com/samstringzz/alutamarket-backend/internals/product"
	"github.com/samstringzz/alutamarket-backend/internals/shared"
	"github.com/samstringzz/alutamarket-backend/internals/store"
	"github.com/samstringzz/alutamarket-backend/internals/subscriber"
	"github.com/samstringzz/alutamarket-backend/internals/user"
	"github.com/samstringzz/alutamarket-backend/internals/withdrawal"
	"github.com/samstringzz/alutamarket-backend/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	// Convert GraphQL input to user service input
	defaultDob := time.Now().Format("2006-01-02")
	defaultGender := "unspecified"
	createUserReq := &user.CreateUserReq{
		Fullname:           input.Fullname,
		Email:              input.Email,
		Password:           input.Password,
		Phone:              input.Phone,
		Campus:             input.Campus,
		Usertype:           input.Usertype,
		Active:             false,
		Twofa:              false,
		StoreName:          "",
		StoreEmail:         "",
		HasPhysicalAddress: false,
		UUID:               utils.GenerateUUID(),
		Avatar:             "https://icon-library.com/images/anonymous-avatar-icon/anonymous-avatar-icon-25.jpg",
		Dob:                &defaultDob,
		Gender:             defaultGender,
		Online:             false,
		FollowedStores:     []string{},
		PaymentDetails: user.PaymentDetails{
			Name:    "",
			Phone:   "",
			Address: "",
			Info:    "",
		},
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Handle store details if provided and usertype is seller
	if input.Stores != nil && input.Usertype == "seller" {
		createUserReq.StoreName = input.Stores.Name
		createUserReq.StoreEmail = input.Email
		createUserReq.StorePhone = input.Stores.Phone
		createUserReq.StoreLink = input.Stores.Link
		createUserReq.Description = input.Stores.Description
		createUserReq.StoreAddress = input.Stores.Address
		createUserReq.HasPhysicalAddress = input.Stores.HasPhysicalAddress
	}

	// Add detailed request logging
	fmt.Printf("Creating user with request: %+v\n", createUserReq)

	// Call the user handler to create user
	result, err := r.UserHandler.CreateUser(ctx, createUserReq)
	if err != nil {
		fmt.Printf("CreateUser detailed error: %+v\n", err)
		fmt.Printf("CreateUser error type: %T\n", err)
		return nil, fmt.Errorf("failed to create user: %v", err)
	}

	// Type assert the Data interface{} to User struct
	userData, ok := result.Data.(*user.User)
	if !ok {
		return nil, fmt.Errorf("invalid user data format")
	}

	// Set default values for required fields if they're nil
	active := true
	if userData.Active != nil {
		active = *userData.Active
	}

	// Convert user service response to GraphQL model
	userResponse := &model.User{
		ID:           strconv.FormatInt(int64(userData.ID), 10),
		Fullname:     userData.Fullname,
		Email:        userData.Email,
		Phone:        userData.Phone,
		Campus:       userData.Campus,
		Usertype:     userData.Usertype,
		Active:       active,
		AccessToken:  &userData.AccessToken,
		RefreshToken: &userData.RefreshToken,
	}

	// If user is a seller, fetch their store
	if userData.Usertype == "seller" {
		storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
		userStore, err := storeHandler.GetStore(ctx, userData.ID)
		if err == nil && userStore != nil {
			userResponse.Stores = []*model.Store{{
				ID:                 strconv.Itoa(int(userStore.ID)),
				Name:               userStore.Name,
				Link:               userStore.Link,
				Description:        userStore.Description,
				Address:            userStore.Address,
				Phone:              userStore.Phone,
				HasPhysicalAddress: userStore.HasPhysicalAddress,
				Thumbnail:          userStore.Thumbnail,
				Background:         userStore.Background,
				Status:             userStore.Status,
				User:               int(userStore.UserID),
			}}

			// Create DVA account
			dvaDetails := &user.DVADetails{
				User:      *userData,
				StoreName: createUserReq.StoreName,
			}

			_, err := r.UserHandler.CreateDVAAccount(ctx, dvaDetails)
			if err != nil {
				log.Printf("Warning: Failed to create DVA account: %v", err)
			}
		}
	}
	return userResponse, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.StoreOrderInput) (*model.StoreOrder, error) {
	panic(fmt.Errorf("not implemented: CreateOrder - createOrder"))
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, input model.UpdateStoreOrderInput) (*model.StoreOrder, error) {
	panic(fmt.Errorf("not implemented: UpdateOrder - updateOrder"))
}

// UpdateStatus resolver for the orders.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderUUID string, status string) (*model.Order, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get the order details first to access the products
	order, err := storeHandler.GetOrderByUUID(ctx, orderUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get order details: %v", err)
	}

	// Update the order status
	err = storeHandler.UpdateOrderStatus(ctx, orderUUID, status, "paid")
	if err != nil {
		return nil, fmt.Errorf("failed to update order status: %v", err)
	}

	// If the status is being updated to "pending" or "processing", update the units sold
	if status == "pending" || status == "processing" {
		// Update units sold for each product in the order
		for _, product := range order.Products {
			err = storeHandler.UpdateProductUnitsSold(ctx, product.ID)
			if err != nil {
				log.Printf("Error updating units sold for product %d: %v", product.ID, err)
				continue
			}
		}
	}

	// Return a basic success response
	return &model.Order{
		UUID:        orderUUID,
		Status:      status,
		TransStatus: "paid",
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input *model.UpdateUserInput) (*model.User, error) {
	// Check if ID is provided
	if input.ID == nil {
		return nil, fmt.Errorf("user ID is required")
	}

	// Convert string ID to uint32
	userID, err := strconv.ParseUint(*input.ID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %v", err)
	}

	// Create update request
	updateReq := &user.UpdateUserReq{
		ID: uint32(userID),
	}

	// Handle optional fields
	if input.Fullname != nil {
		updateReq.Fullname = *input.Fullname
	}
	if input.Email != nil {
		updateReq.Email = *input.Email
	}
	if input.Campus != nil {
		updateReq.Campus = *input.Campus
	}
	if input.Phone != nil {
		updateReq.Phone = *input.Phone
	}
	if input.Avatar != nil {
		updateReq.Avatar = *input.Avatar
	}
	if input.Dob != nil {
		updateReq.Dob = *input.Dob
	}
	// Add store-related fields
	if input.StoreName != nil {
		updateReq.StoreName = *input.StoreName
	}
	if input.StoreEmail != nil {
		updateReq.StoreEmail = *input.StoreEmail
	}
	if input.HasPhysicalAddress != nil {
		updateReq.HasPhysicalAddress = *input.HasPhysicalAddress
	}

	if input.PaymentDetails != nil {
		updateReq.PaymentDetails = user.PaymentDetails{
			Name:    input.PaymentDetails.Name,
			Phone:   input.PaymentDetails.Phone,
			Address: input.PaymentDetails.Address,
			Info:    input.PaymentDetails.Info,
		}
	}

	// Call the user handler to update user
	result, err := r.UserHandler.UpdateUser(ctx, updateReq)
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}

	// Convert user service response to GraphQL model
	userResponse := &model.User{
		ID:           strconv.FormatInt(int64(result.ID), 10),
		UUID:         result.UUID,
		Fullname:     result.Fullname,
		Email:        result.Email,
		Phone:        result.Phone,
		Campus:       result.Campus,
		Usertype:     result.Usertype,
		Active:       *result.Active,
		AccessToken:  &result.AccessToken,
		RefreshToken: &result.RefreshToken,
		Online:       result.Online,
	}

	// If user is a seller, create and fetch their store
	if result.Usertype == "seller" && input.Stores != nil {
		storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

		// Create store with input details
		storeInput := &store.Store{
			Name:               input.Stores.Name,
			Link:               input.Stores.Link,
			UserID:             result.ID,
			Description:        input.Stores.Description,
			Address:            input.Stores.Address,
			Phone:              input.Stores.Phone,
			HasPhysicalAddress: input.Stores.HasPhysicalAddress,
			Email:              result.Email,
			Status:             true,
		}

		createdStore, err := storeHandler.CreateStore(ctx, storeInput)
		if err == nil && createdStore != nil {
			userResponse.Stores = []*model.Store{{
				ID:                 strconv.Itoa(int(createdStore.ID)),
				Name:               createdStore.Name,
				Link:               createdStore.Link,
				Description:        createdStore.Description,
				Address:            createdStore.Address,
				Phone:              createdStore.Phone,
				HasPhysicalAddress: createdStore.HasPhysicalAddress,
				Thumbnail:          createdStore.Thumbnail,
				Background:         createdStore.Background,
				Status:             createdStore.Status,
				User:               int(createdStore.UserID),
			}}
		}
	}

	return userResponse, nil
}

// AddEmailSubscriber is the resolver for the addEmailSubscriber field.
func (r *mutationResolver) AddEmailSubscriber(ctx context.Context, email string) (*model.EmailSubscriptionResponse, error) {
	// Create subscriber service and repository
	subscriberRepo := subscriber.NewRepository()
	subscriberService := subscriber.NewService(subscriberRepo)

	// First add to OneSignal
	err := utils.AddEmailSubscriber(email)
	if err != nil {
		errMsg := fmt.Sprintf("Failed to add subscriber to OneSignal: %v", err)
		return &model.EmailSubscriptionResponse{
			Success: false,
			Message: &errMsg,
		}, nil
	}

	// Then add to database
	_, err = subscriberService.CreateSubscriber(email)
	if err != nil {
		errMsg := fmt.Sprintf("Failed to add subscriber to database: %v", err)
		return &model.EmailSubscriptionResponse{
			Success: false,
			Message: &errMsg,
		}, nil
	}

	successMsg := "Successfully subscribed to email notifications"
	return &model.EmailSubscriptionResponse{
		Success: true,
		Message: &successMsg,
	}, nil
}

// SubscribeEmail is the resolver for the subscribeEmail field.
func (r *mutationResolver) SubscribeEmail(ctx context.Context, email string) (*model.Subscriber, error) {
	panic(fmt.Errorf("not implemented: SubscribeEmail - subscribeEmail"))
}

// UnsubscribeEmail is the resolver for the unsubscribeEmail field.
func (r *mutationResolver) UnsubscribeEmail(ctx context.Context, email string) (bool, error) {
	panic(fmt.Errorf("not implemented: UnsubscribeEmail - unsubscribeEmail"))
}

// CreateVerifyOtp is the resolver for the createVerifyOTP field.
func (r *mutationResolver) CreateVerifyOtp(ctx context.Context, input model.NewVerifyOtp) (*model.LoginRes, error) {
	// Create verification request
	verifyReq := &user.VerifyOTPReq{
		Code:     input.Code,
		Phone:    input.Phone,
		Attempts: input.Attempts,
	}

	// Handle optional email field
	if input.Email != nil {
		verifyReq.Email = *input.Email
	}

	// Call user handler to verify OTP
	result, err := r.UserHandler.VerifyOTP(ctx, verifyReq)
	if err != nil {
		return nil, fmt.Errorf("OTP verification failed: %v", err)
	}

	// Convert response to GraphQL model
	return &model.LoginRes{
		ID:           int(result.ID),
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginReq) (*model.LoginRes, error) {
	loginReq := &user.LoginUserReq{
		Email:    input.Email,
		Password: input.Password,
	}

	result, err := r.UserHandler.Login(ctx, loginReq)
	if err != nil {
		return nil, err
	}

	return &model.LoginRes{
		ID:           int(result.ID),
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// AddHandledProduct is the resolver for the addHandledProduct field.
func (r *mutationResolver) AddHandledProduct(ctx context.Context, userID int, productID int, typeArg string) (*model.HandledProducts, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert int to uint32 for the handler
	userIDUint := uint32(userID)
	productIDUint := uint32(productID)

	// First, check if the product exists in handled products
	products, err := productHandler.GetHandledProducts(ctx, userIDUint, typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing products: %v", err)
	}

	// Check if product already exists
	for _, p := range products {
		if p.Product != nil && p.Product.ID == productIDUint {
			// Return the existing product instead of error
			status := p.Product.Status
			price := p.Product.Price
			discount := p.Product.Discount
			quantity := p.Product.Quantity
			name := p.Product.Name
			thumbnail := p.Product.Thumbnail

			return &model.HandledProducts{
				UserID:           int(p.UserID),
				ProductID:        int(p.Product.ID),
				ProductName:      &name,
				ProductThumbnail: &thumbnail,
				ProductPrice:     &price,
				ProductDiscount:  &discount,
				ProductStatus:    &status,
				ProductQuantity:  &quantity,
			}, nil
		}
	}

	// If product doesn't exist, add it
	result, err := productHandler.AddHandledProduct(ctx, userIDUint, productIDUint, typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to add handled product: %v", err)
	}

	// Convert to GraphQL model
	status := result.Product.Status
	price := result.Product.Price
	discount := result.Product.Discount
	quantity := result.Product.Quantity
	name := result.Product.Name
	thumbnail := result.Product.Thumbnail

	return &model.HandledProducts{
		UserID:           int(result.UserID),
		ProductID:        int(result.Product.ID),
		ProductName:      &name,
		ProductThumbnail: &thumbnail,
		ProductPrice:     &price,
		ProductDiscount:  &discount,
		ProductStatus:    &status,
		ProductQuantity:  &quantity,
	}, nil
}

// AddReview is the resolver for the addReview field.
func (r *mutationResolver) AddReview(ctx context.Context, input model.ReviewInput) (*model.Review, error) {
	db := database.GetDB()
	if db == nil {
		return nil, fmt.Errorf("database connection failed")
	}

	now := time.Now()

	// Create the review in the database
	review := &model.Review{
		StoreID:   input.StoreID,
		ProductID: input.ProductID,
		OrderID:   input.OrderID,
		SellerID:  input.SellerID,
		Rating:    input.Rating,
		CreatedAt: &now,
		UpdatedAt: &now,
	}

	if input.Buyer != nil {
		review.Buyer = &model.ReviewBuyer{
			Nickname: input.Buyer.Nickname,
			Avatar:   input.Buyer.Avatar,
			Comment:  input.Buyer.Comment,
		}
		// Set the message from buyer's comment
		review.Message = &input.Buyer.Comment
	}

	// Insert the review into the database
	result := db.Table("reviews").Create(&struct {
		StoreID   int       `json:"store_id"`
		ProductID int       `json:"product_id"`
		OrderID   string    `json:"order_id"`
		SellerID  int       `json:"seller_id"`
		BuyerID   int       `json:"buyer_id"`
		Rating    float64   `json:"rating"`
		Message   string    `json:"message"`
		CreatedAt time.Time `json:"created_at"`
		UpdatedAt time.Time `json:"updated_at"`
		Nickname  string    `json:"nickname"`
		Avatar    string    `json:"avatar"`
		Username  string    `json:"username"`
	}{
		StoreID:   input.StoreID,
		ProductID: input.ProductID,
		OrderID:   input.OrderID,
		SellerID:  input.SellerID,
		BuyerID:   input.BuyerID,
		Rating:    input.Rating,
		Message:   input.Buyer.Comment,
		CreatedAt: *review.CreatedAt,
		UpdatedAt: *review.UpdatedAt,
		Nickname:  input.Buyer.Nickname,
		Avatar:    input.Buyer.Avatar,
		Username:  input.Buyer.Nickname,
	})

	if result.Error != nil {
		return nil, fmt.Errorf("failed to create review: %v", result.Error)
	}

	return review, nil
}

// CheckStoreName is the resolver for the checkStoreName field.
func (r *mutationResolver) CheckStoreName(ctx context.Context, input string) (*string, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	err := storeHandler.CheckStoreName(ctx, input)
	if err != nil {
		return nil, err
	}

	// If no error, return the store name as available
	result := "Store name available"
	return &result, nil
}

// UpdateStoreFollower is the resolver for the updateStoreFollower field.
func (r *mutationResolver) UpdateStoreFollower(ctx context.Context, input *model.StoreFollowerInput) (*model.Store, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Convert input to store follower type
	follower := &store.Follower{
		FollowerID:    uint32(input.FollowerID),
		FollowerName:  input.FollowerName,
		FollowerImage: input.FollowerImage,
		StoreID:       uint32(input.StoreID),
	}

	// Update store follower - using the correct method name
	updatedStore, err := storeHandler.UpdateStoreFollowership(ctx, follower.StoreID, follower, "follow")
	if err != nil {
		return nil, fmt.Errorf("failed to update store follower: %v", err)
	}

	// Convert followers to GraphQL model
	var followers []*model.StoreFollower
	for _, f := range updatedStore.Followers {
		followers = append(followers, &model.StoreFollower{
			FollowerID:    int(f.FollowerID),
			FollowerName:  f.FollowerName,
			StoreID:       int(f.StoreID),
			FollowerImage: f.FollowerImage,
		})
	}

	// Convert products to GraphQL model
	var products []*model.Product
	for _, p := range updatedStore.Products {
		products = append(products, &model.Product{
			ID:          int(p.ID),
			Name:        p.Name,
			Price:       p.Price,
			Description: p.Description,
			Discount:    p.Discount,
			Image:       p.Images,
			Slug:        p.Slug,
			Quantity:    p.Quantity,
			Status:      p.Status,
			Thumbnail:   p.Thumbnail,
			Store:       p.Store,
			Category:    p.Category,
			Subcategory: p.Subcategory,
		})
	}

	return &model.Store{
		ID:                 strconv.Itoa(int(updatedStore.ID)),
		Link:               updatedStore.Link,
		Name:               updatedStore.Name,
		User:               int(updatedStore.UserID),
		Description:        updatedStore.Description,
		Thumbnail:          updatedStore.Thumbnail,
		Phone:              updatedStore.Phone,
		Background:         updatedStore.Background,
		Address:            updatedStore.Address,
		Status:             updatedStore.Status,
		HasPhysicalAddress: updatedStore.HasPhysicalAddress,
		Wallet:             float64(updatedStore.Wallet),
		Visitors:           updatedStore.Visitors,
		Followers:          followers,
		Product:            products,
	}, nil
}

// CreateSkynet is the resolver for the createSkynet field.
func (r *mutationResolver) CreateSkynet(ctx context.Context, input *model.SkynetInput) (string, error) {
	panic(fmt.Errorf("not implemented: CreateSkynet - createSkynet"))
}

// RemoveHandledProduct is the resolver for the removeHandledProduct field.
func (r *mutationResolver) RemoveHandledProduct(ctx context.Context, prd int, typeArg *string) (*model.HandledProducts, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert int to uint32
	productID := uint32(prd)

	// Get the product details before removal
	products, err := productHandler.GetHandledProducts(ctx, 0, *typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to get handled products: %v", err)
	}

	// Find the specific product
	var targetProduct *product.HandledProduct
	for _, p := range products {
		if p.ProductID == productID {
			targetProduct = p
			break
		}
	}

	if targetProduct == nil {
		return nil, fmt.Errorf("product not found in handled products")
	}

	// Remove the handled product
	err = productHandler.RemoveHandledProduct(ctx, productID, *typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to remove handled product: %v", err)
	}

	// Get the product details to return in response
	productDetails, err := productHandler.GetProduct(ctx, productID, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to get product details: %v", err)
	}

	// Prepare the response
	status := productDetails.Status
	price := productDetails.Price
	discount := productDetails.Discount
	quantity := productDetails.Quantity
	name := productDetails.Name
	thumbnail := productDetails.Thumbnail

	return &model.HandledProducts{
		UserID:           int(targetProduct.UserID),
		ProductID:        int(productDetails.ID),
		ProductName:      &name,
		ProductThumbnail: &thumbnail,
		ProductPrice:     &price,
		ProductDiscount:  &discount,
		ProductStatus:    &status,
		ProductQuantity:  &quantity,
	}, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.NewCategory) (*model.Category, error) {
	panic(fmt.Errorf("not implemented: CreateCategory - createCategory"))
}

// CreateSubCategory is the resolver for the createSubCategory field.
func (r *mutationResolver) CreateSubCategory(ctx context.Context, input model.NewSubCategory) (*model.SubCategory, error) {
	panic(fmt.Errorf("not implemented: CreateSubCategory - createSubCategory"))
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	// Add debug logging
	fmt.Printf("Creating product with category ID: %d, subcategory: %s\n", input.Category, input.Subcategory)
	// Convert input to internal product structure
	newProduct := &product.NewProduct{
		Name:            input.Name,
		Description:     input.Description,
		Images:          input.Image,
		Thumbnail:       input.Thumbnail,
		Price:           input.Price,
		Discount:        input.Discount,
		Status:          &input.Status,
		Quantity:        input.Quantity,
		File:            input.File,
		Store:           input.Store,
		CategoryID:      uint8(input.Category),
		SubCategoryName: input.Subcategory,
		AlwaysAvailbale: input.AlwaysAvailable,
	}

	// Handle variant conversion if present
	if input.Variant != nil {
		variants := make([]*product.VariantType, 0)
		for _, v := range input.Variant {
			variant := &product.VariantType{
				Name:  v.Name,
				Value: make([]*product.VariantValue, 0),
			}
			for _, val := range v.Value {
				if val.Price != nil {
					variant.Value = append(variant.Value, &product.VariantValue{
						Value:  val.Value,
						Price:  *val.Price, // Dereference the pointer
						Images: val.Images,
					})
				}
			}
			variants = append(variants, variant)
		}
		newProduct.Variant = variants
	}

	// Log the category lookup
	fmt.Printf("Looking up category and subcategory: %+v\n", newProduct)

	// Create product
	createdProduct, err := r.ProductHandler.CreateProduct(ctx, newProduct)
	if err != nil {
		fmt.Printf("Error creating product: %v\n", err)
		return nil, fmt.Errorf("failed to create product: %v", err)
	}

	// Convert to GraphQL model
	return &model.Product{
		ID:              int(createdProduct.ID),
		Name:            createdProduct.Name,
		Description:     createdProduct.Description,
		Price:           createdProduct.Price,
		Discount:        createdProduct.Discount,
		Status:          createdProduct.Status,
		Quantity:        createdProduct.Quantity,
		Thumbnail:       createdProduct.Thumbnail,
		Image:           createdProduct.Images,
		File:            &createdProduct.File,
		Store:           createdProduct.Store,
		Category:        createdProduct.Category,
		Subcategory:     createdProduct.Subcategory,
		AlwaysAvailable: &createdProduct.AlwaysAvailbale,
	}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input *model.UpdateProductInput) (*model.Product, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert string ID to uint32
	productID, err := strconv.ParseUint(input.ID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %v", err)
	}

	// Create update request with only the ID initially
	updateReq := &product.NewProduct{
		ID: strconv.FormatUint(uint64(productID), 10),
	}

	// Only set fields that are provided in the input, with proper dereferencing
	if input.Name != nil {
		updateReq.Name = *input.Name
	}
	if input.Price != nil {
		updateReq.Price = *input.Price
	}
	if input.Description != nil {
		updateReq.Description = *input.Description
	}
	if input.Discount != nil {
		updateReq.Discount = *input.Discount
	}
	if input.Quantity != nil {
		updateReq.Quantity = *input.Quantity
	}
	if input.Status != nil {
		updateReq.Status = input.Status
	}
	if input.Thumbnail != nil {
		updateReq.Thumbnail = *input.Thumbnail
	}
	if input.Category != nil {
		updateReq.CategoryID = uint8(*input.Category)
	}
	if input.Subcategory != nil {
		updateReq.SubCategoryName = *input.Subcategory
	}
	if input.AlwaysAvailable != nil {
		updateReq.AlwaysAvailbale = *input.AlwaysAvailable
	}

	// Call the product handler to update the product
	updatedProduct, err := productHandler.UpdateProduct(ctx, updateReq)
	if err != nil {
		return nil, fmt.Errorf("failed to update product: %v", err)
	}

	// Return the updated product data
	return &model.Product{
		ID:              int(updatedProduct.ID),
		Name:            updatedProduct.Name,
		Price:           updatedProduct.Price,
		Description:     updatedProduct.Description,
		Discount:        updatedProduct.Discount,
		Quantity:        updatedProduct.Quantity,
		Status:          updatedProduct.Status,
		Thumbnail:       updatedProduct.Thumbnail,
		Category:        updatedProduct.Category,
		Subcategory:     updatedProduct.Subcategory,
		AlwaysAvailable: &updatedProduct.AlwaysAvailbale,
	}, nil
}

// ToggleStoreFollowStatus is the resolver for the toggleStoreFollowStatus field.
func (r *mutationResolver) ToggleStoreFollowStatus(ctx context.Context, user int, store int) (*string, error) {
	panic(fmt.Errorf("not implemented: ToggleStoreFollowStatus - toggleStoreFollowStatus"))
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, productID int) (*model.Product, error) {
	// Get product before deletion to return its data
	product, err := r.ProductHandler.GetProduct(ctx, uint32(productID), 0)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product: %v", err)
	}

	// Delete the product
	err = r.ProductHandler.DeleteProduct(ctx, uint32(productID))
	if err != nil {
		return nil, fmt.Errorf("failed to delete product: %v", err)
	}

	// Return the deleted product data
	return &model.Product{
		ID:              int(product.ID),
		Name:            product.Name,
		Slug:            product.Slug,
		Description:     product.Description,
		Price:           product.Price,
		Discount:        product.Discount,
		Status:          product.Status,
		Quantity:        product.Quantity,
		Thumbnail:       product.Thumbnail,
		Image:           product.Images,
		File:            &product.File,
		Store:           product.Store,
		Category:        product.Category,
		Subcategory:     product.Subcategory,
		AlwaysAvailable: &product.AlwaysAvailbale,
		Type:            &product.Type,
	}, nil
}

// ModifyCart is the resolver for the modifyCart field.
func (r *mutationResolver) ModifyCart(ctx context.Context, input model.ModifyCartItemInput) (*model.Cart, error) {
	cartHandler := cart.NewHandler(cart.NewService(cart.NewRepository()))

	// Create cart item
	cartItem := &cart.CartItems{
		Product: &product.Product{
			ID: 0,
		},
		Quantity: input.Quantity,
	}

	// Set product ID if provided
	if input.ProductID != nil {
		id, err := strconv.ParseUint(*input.ProductID, 10, 32)
		if err != nil {
			return nil, fmt.Errorf("invalid product ID: %v", err)
		}
		cartItem.Product.ID = uint32(id)
	}

	// Set product name if provided
	if input.ProductName != nil {
		cartItem.Product.Name = *input.ProductName
	}

	// Modify cart
	result, err := cartHandler.ModifyCart(ctx, cartItem, uint32(input.User))
	if err != nil {
		return nil, fmt.Errorf("failed to modify cart: %v", err)
	}

	// Convert cart items to GraphQL model
	var cartItems []*model.CartItem
	for _, item := range result.Items {
		cartItem := &model.CartItem{
			Product: &model.Product{
				ID:        int(item.Product.ID),
				Name:      item.Product.Name,
				Price:     item.Product.Price,
				Discount:  item.Product.Discount,
				Quantity:  item.Product.Quantity,
				Thumbnail: item.Product.Thumbnail,
				Image:     item.Product.Images,
				Store:     item.Product.Store,
			},
			Quantity: item.Quantity,
		}
		cartItems = append(cartItems, cartItem)
	}

	// Convert ID to string
	id := strconv.FormatUint(uint64(result.ID), 10)

	return &model.Cart{
		Items:  cartItems,
		Total:  result.Total,
		Active: result.Active,
		User:   int(result.UserID),
		ID:     &id,
	}, nil
}

// RemoveAllCart is the resolver for the removeAllCart field.
func (r *mutationResolver) RemoveAllCart(ctx context.Context, cartID int) (*model.Cart, error) {
	cartHandler := cart.NewHandler(cart.NewService(cart.NewRepository()))

	// Convert int to uint32 for the handler
	cartIDUint := uint32(cartID)

	// Get cart before removing
	result, err := cartHandler.GetCart(ctx, cartIDUint)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch cart: %v", err)
	}

	// Remove all items from cart
	err = cartHandler.RemoveAllCart(ctx, cartIDUint)
	if err != nil {
		return nil, fmt.Errorf("failed to remove cart: %v", err)
	}

	// Convert cart items to GraphQL model
	var cartItems []*model.CartItem
	for _, item := range result.Items {
		cartItem := &model.CartItem{
			Product: &model.Product{
				ID:        int(item.Product.ID),
				Name:      item.Product.Name,
				Price:     item.Product.Price,
				Discount:  item.Product.Discount,
				Quantity:  item.Product.Quantity,
				Thumbnail: item.Product.Thumbnail,
				Image:     item.Product.Images,
				Store:     item.Product.Store,
			},
			Quantity: item.Quantity,
		}
		cartItems = append(cartItems, cartItem)
	}

	// Convert ID to string
	id := strconv.FormatUint(uint64(result.ID), 10)

	return &model.Cart{
		Items:  cartItems,
		Total:  result.Total,
		Active: false, // Cart is now inactive
		User:   int(result.UserID),
		ID:     &id,
	}, nil
}

// CreateStore is the resolver for the createStore field.
func (r *mutationResolver) CreateStore(ctx context.Context, input model.StoreInput) (*model.Store, error) {
	// Handle optional fields
	email := ""
	if input.Email != nil {
		email = *input.Email
	}

	thumbnail := ""
	if input.Thumbnail != nil {
		thumbnail = *input.Thumbnail
	}

	background := ""
	if input.Background != nil {
		background = *input.Background
	}

	// Convert input to store.Store
	storeInput := &store.Store{
		Name:               input.Name,
		Link:               input.Link,
		UserID:             uint32(input.User),
		Description:        input.Description,
		Address:            input.Address,
		Phone:              input.Phone,
		HasPhysicalAddress: input.HasPhysicalAddress,
		Email:              email,
		Thumbnail:          thumbnail,
		Background:         background,
		Status:             input.Status,
	}

	// Call the store handler
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
	createdStore, err := storeHandler.CreateStore(ctx, storeInput)
	if err != nil {
		return nil, fmt.Errorf("failed to create store: %v", err)
	}

	// Convert store.Store to model.Store
	return &model.Store{
		ID:                 strconv.Itoa(int(createdStore.ID)),
		Name:               createdStore.Name,
		Link:               createdStore.Link,
		User:               int(createdStore.UserID),
		Description:        createdStore.Description,
		Address:            createdStore.Address,
		Phone:              createdStore.Phone,
		HasPhysicalAddress: createdStore.HasPhysicalAddress,
		Email:              createdStore.Email,
		Thumbnail:          createdStore.Thumbnail,
		Background:         createdStore.Background,
		Status:             createdStore.Status,
		Wallet:             createdStore.Wallet,
	}, nil
}

// UpdateStore is the resolver for the updateStore field.
func (r *mutationResolver) UpdateStore(ctx context.Context, input *model.UpdateStoreInput) (*model.Store, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Check if ID is provided
	if input.ID == nil {
		return nil, fmt.Errorf("store ID is required")
	}

	// Convert string ID to uint32
	id, err := strconv.ParseUint(*input.ID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid store ID: %v", err)
	}

	// Create store update struct
	updateStore := &store.UpdateStore{
		ID: uint32(id),
	}

	// Handle optional fields
	if input.Name != nil {
		updateStore.Name = *input.Name
	}
	if input.Link != nil {
		updateStore.Link = *input.Link
	}
	if input.Description != nil {
		updateStore.Description = *input.Description
	}
	if input.Address != nil {
		updateStore.Address = *input.Address
	}
	if input.Phone != nil {
		updateStore.Phone = *input.Phone
	}
	if input.Email != nil {
		updateStore.Email = *input.Email
	}
	if input.Thumbnail != nil {
		updateStore.Thumbnail = *input.Thumbnail
	}
	if input.Background != nil {
		updateStore.Background = *input.Background
	}
	if input.HasPhysicalAddress != nil {
		updateStore.HasPhysicalAddress = *input.HasPhysicalAddress
	}
	if input.Status != nil {
		updateStore.Status = *input.Status
	}
	if input.MaintenanceMode != nil {
		updateStore.MaintenanceMode = *input.MaintenanceMode
	}

	// Handle visitor array - convert to string array
	if len(input.Visitor) > 0 {
		visitorStrings := make([]string, 0, len(input.Visitor))
		for _, v := range input.Visitor {
			if v != nil {
				visitorStrings = append(visitorStrings, *v)
			}
		}
		updateStore.Visitors = visitorStrings
	}

	// Handle account information if provided
	if input.Account != nil {
		// Set the account details directly without creating a DVA account
		updateStore.Account = &store.WithdrawalAccount{
			BankName:      input.Account.BankName,
			BankCode:      input.Account.BankCode,
			BankImage:     input.Account.BankImage,
			AccountNumber: input.Account.AccountNumber,
			AccountName:   input.Account.AccountName,
		}
	}

	// Update the store
	updatedStore, err := storeHandler.UpdateStore(ctx, updateStore)
	if err != nil {
		return nil, fmt.Errorf("failed to update store: %v", err)
	}

	// Convert followers to GraphQL model
	var followers []*model.StoreFollower
	for _, f := range updatedStore.Followers {
		followers = append(followers, &model.StoreFollower{
			FollowerID:    int(f.FollowerID),
			FollowerName:  f.FollowerName,
			StoreID:       int(f.StoreID),
			FollowerImage: f.FollowerImage,
		})
	}

	// Convert products to GraphQL model
	var products []*model.Product
	for _, p := range updatedStore.Products {
		products = append(products, &model.Product{
			ID:          int(p.ID),
			Name:        p.Name,
			Price:       p.Price,
			Description: p.Description,
			Discount:    p.Discount,
			Image:       p.Images,
			Slug:        p.Slug,
			Quantity:    p.Quantity,
			Status:      p.Status,
			Thumbnail:   p.Thumbnail,
			Store:       p.Store,
			Category:    p.Category,
			UnitsSold:   p.UnitsSold,
			Subcategory: p.Subcategory,
		})
	}

	// Convert accounts to GraphQL model
	var accounts []*model.WithdrawAccount
	if updatedStore.Accounts != nil {
		for _, a := range updatedStore.Accounts {
			accounts = append(accounts, &model.WithdrawAccount{
				BankCode:      a.BankCode,
				BankName:      a.BankName,
				BankImage:     a.BankImage,
				AccountNumber: a.AccountNumber,
				AccountName:   a.AccountName,
			})
		}
	}

	return &model.Store{
		ID:                 strconv.Itoa(int(updatedStore.ID)),
		Link:               updatedStore.Link,
		Name:               updatedStore.Name,
		User:               int(updatedStore.UserID),
		Description:        updatedStore.Description,
		Thumbnail:          updatedStore.Thumbnail,
		Phone:              updatedStore.Phone,
		Background:         updatedStore.Background,
		Address:            updatedStore.Address,
		Status:             updatedStore.Status,
		HasPhysicalAddress: updatedStore.HasPhysicalAddress,
		Wallet:             float64(updatedStore.Wallet),
		Visitors:           updatedStore.Visitors,
		Followers:          followers,
		Product:            products,
		Accounts:           accounts,
		MaintenanceMode:    updatedStore.MaintenanceMode,
	}, nil
}

// DeleteStore is the resolver for the deleteStore field.
func (r *mutationResolver) DeleteStore(ctx context.Context, storeID int) (*model.Store, error) {
	panic(fmt.Errorf("not implemented: DeleteStore - deleteStore"))
}

// Update the CreateDVAAccount resolver
func (r *mutationResolver) CreateDVAAccount(ctx context.Context, input model.DVAAccountInput) (string, error) {
	// Get existing user
	existingUser, err := r.UserHandler.GetUser(ctx, input.UserID)
	if err != nil {
		return "", fmt.Errorf("failed to get user details: %v", err)
	}

	// Only proceed if user is a seller
	if existingUser.Usertype != "seller" {
		return "", fmt.Errorf("only sellers can create DVA accounts")
	}

	// Create DVA details
	dvaDetails := &user.DVADetails{
		User:       *existingUser,
		StoreName:  input.StoreName,
		StoreEmail: existingUser.Email,
	}

	// Create DVA account using UserHandler
	accountID, err := r.UserHandler.CreateDVAAccount(ctx, dvaDetails)
	if err != nil {
		return "", fmt.Errorf("failed to create DVA account: %v", err)
	}

	return accountID, nil
}

// InitializePayment is the resolver for the initializePayment field.
func (r *mutationResolver) InitializePayment(ctx context.Context, input model.PaymentData) (*string, error) {
	cartHandler := cart.NewHandler(cart.NewService(cart.NewRepository()))

	amountStr := strconv.FormatFloat(*input.Amount, 'f', 2, 64)

	// Create order with required fields
	order := store.Order{
		UserID:         input.UserID,
		UUID:           *input.UUID,
		PaymentGateway: *input.PaymentGateway,
		Amount:         amountStr,
		Status:         "pending",
		CreatedAt:      time.Now(),
		UpdatedAt:      time.Now(),
	}

	// Initialize payment
	paymentLink, err := cartHandler.IntitiatePayment(ctx, &order)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize payment: %v", err)
	}

	return &paymentLink, nil
}

// VerifySmartCard is the resolver for the verifySmartCard field.
func (r *mutationResolver) VerifySmartCard(ctx context.Context, input model.SmartCardInput) (*model.SmartcardVerificationResponse, error) {
	panic(fmt.Errorf("not implemented: VerifySmartCard - verifySmartCard"))
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, input model.ChatInput) (*model.Chat, error) {
	// Recover from panics
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Recovered from panic in CreateChat: %v", r)
		}
	}()

	// Check if MessageHandler is initialized
	if r.MessageHandler == nil {
		r.MessageHandler = messages.NewMessageHandler(messages.NewService(messages.NewRepository()))
	}

	// Input validation
	if len(input.Users) == 0 {
		return nil, fmt.Errorf("at least one user is required")
	}

	var users []*user.User
	for _, u := range input.Users {
		if u == nil {
			continue
		}

		var avatar string
		if u.Avatar != nil {
			avatar = *u.Avatar
		}

		// Get existing user to preserve their UUID
		existingUser, err := r.UserHandler.GetUser(ctx, strconv.Itoa(u.ID))
		if err != nil {
			return nil, fmt.Errorf("failed to get user data: %v", err)
		}

		users = append(users, &user.User{
			ID:       uint32(u.ID),
			UUID:     existingUser.UUID, // Use existing UUID
			Fullname: u.Fullname,
			Avatar:   avatar,
		})
	}

	// Create chat with basic fields
	chat, err := r.MessageHandler.FindOrCreateChat(ctx, users)
	if err != nil {
		log.Printf("Chat creation error details: %+v", err)
		return nil, fmt.Errorf("failed to create chat: %v", err)
	}

	var messageUsers []*model.User
	for _, u := range users {
		messageUser := &model.User{
			ID:       strconv.Itoa(int(u.ID)),
			UUID:     u.UUID,
			Fullname: u.Fullname,
			Avatar:   &u.Avatar,
		}
		messageUsers = append(messageUsers, messageUser)
	}

	return &model.Chat{
		ID:       strconv.FormatInt(int64(chat.ID), 10),
		Messages: []*model.Message{},
		Users:    messageUsers,
	}, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.MessageInput) (*model.Message, error) {
	// Convert int to string first
	chatIDStr := strconv.Itoa(input.ChatID)
	senderStr := strconv.Itoa(input.Sender)

	chatIDUint, err := strconv.ParseUint(chatIDStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid chat ID: %v", err)
	}

	senderUint, err := strconv.ParseUint(senderStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid sender ID: %v", err)
	}

	msg := &messages.Message{
		ChatID:  uint32(chatIDUint),
		Content: input.Content,
		Sender:  uint32(senderUint),
	}

	if input.Media != nil {
		mediaType := messages.MediaType(*input.Media)
		msg.Media = &mediaType
	}

	err = r.MessageHandler.SendMessage(ctx, msg)
	if err != nil {
		return nil, err
	}

	return &model.Message{
		ID:        strconv.FormatInt(int64(msg.ID), 10),
		ChatID:    strconv.FormatInt(int64(msg.ChatID), 10),
		Content:   msg.Content,
		Sender:    strconv.FormatInt(int64(msg.Sender), 10),
		Media:     (*string)(msg.Media),
		IsRead:    msg.IsRead,
		CreatedAt: msg.CreatedAt.Format(time.RFC3339),
		UpdatedAt: func() *string {
			if !msg.UpdatedAt.IsZero() {
				t := msg.UpdatedAt.Format(time.RFC3339)
				return &t
			}
			return nil
		}(),
	}, nil
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, input model.TransactionInput) (*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: CreateTransaction - createTransaction"))
}

// CreateResetPasswordLink is the resolver for the createResetPasswordLink field.
func (r *mutationResolver) CreateResetPasswordLink(ctx context.Context, input model.PasswordResetInput) (bool, error) {
	panic(fmt.Errorf("not implemented: CreateResetPasswordLink - createResetPasswordLink"))
}

// VerifyResetPasswordLink is the resolver for the verifyResetPasswordLink field.
func (r *mutationResolver) VerifyResetPasswordLink(ctx context.Context, input string) (bool, error) {
	panic(fmt.Errorf("not implemented: VerifyResetPasswordLink - verifyResetPasswordLink"))
}

// UpdateUserPassword is the resolver for the updateUserPassword field.
func (r *mutationResolver) UpdateUserPassword(ctx context.Context, input model.PasswordUpdateInput) (bool, error) {
	panic(fmt.Errorf("not implemented: UpdateUserPassword - updateUserPassword"))
}

// WithdrawFund is the resolver for the withdrawFund field.
func (r *mutationResolver) WithdrawFund(ctx context.Context, input model.FundInput) (bool, error) {
	// Get store repository
	storeRepo := store.NewRepository()

	// Get store and validate user
	storeObj, err := storeRepo.GetStore(ctx, uint32(input.StoreID))
	if err != nil {
		return false, fmt.Errorf("store not found: %w", err)
	}
	if storeObj.UserID != uint32(input.UserID) {
		return false, fmt.Errorf("user not authorized for this store")
	}

	// Check if store has sufficient balance in wallet
	if storeObj.Wallet < float64(input.Amount) {
		return false, fmt.Errorf("insufficient funds in store wallet")
	}

	// Get bank details from dva_accounts table
	var bankDetails struct {
		BankName      string
		AccountName   string
		AccountNumber string
	}
	if err := storeRepo.GetDB().Table("dva_accounts").
		Where("store_id = ? AND account_number = ?", input.StoreID, input.AccountNumber).
		First(&bankDetails).Error; err != nil {
		return false, fmt.Errorf("failed to get bank details: %w", err)
	}

	// Call withdrawal logic
	withdrawalRepo := withdrawal.NewRepository()
	newWithdrawal := &shared.NewWithdrawal{
		StoreID:       uint32(input.StoreID),
		Amount:        float64(input.Amount),
		BankName:      bankDetails.BankName,
		AccountNumber: input.AccountNumber,
		AccountName:   bankDetails.AccountName,
	}
	_, err = withdrawalRepo.CreateWithdrawal(ctx, newWithdrawal)
	if err != nil {
		return false, fmt.Errorf("failed to create withdrawal: %w", err)
	}
	return true, nil
}

// ConfirmPassword is the resolver for the confirmPassword field.
func (r *mutationResolver) ConfirmPassword(ctx context.Context, input *model.ConfirmPasswordInput) (bool, error) {
	if input == nil {
		return false, fmt.Errorf("input cannot be nil")
	}

	userHandler := user.NewHandler(user.NewService(user.NewRepository()))
	err := userHandler.ConfirmPassword(ctx, input.Password, input.UserID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateInvoice is the resolver for the createInvoice field.
func (r *mutationResolver) CreateInvoice(ctx context.Context, input model.InvoiceInput) (*model.Invoice, error) {
	panic(fmt.Errorf("not implemented: CreateInvoice - createInvoice"))
}

// CreatePaystackAccount is the resolver for the createPaystackAccount field.
func (r *mutationResolver) CreatePaystackAccount(ctx context.Context, email string, bvn string) (*model.PaystackAccount, error) {
	panic(fmt.Errorf("not implemented: CreatePaystackAccount - createPaystackAccount"))
}

// UpdateExistingOrdersUnitsSold updates the units sold for all existing orders
func (r *mutationResolver) UpdateExistingOrdersUnitsSold(ctx context.Context) (*model.UpdateUnitsSoldResponse, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get all orders
	orders, err := storeHandler.GetAllOrders(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %v", err)
	}

	updatedCount := 0
	errorCount := 0

	// Process each order
	for _, order := range orders {
		// Only process orders that are pending, processing, completed, or delivered
		if order.Status == "pending" || order.Status == "processing" ||
			order.Status == "completed" || order.Status == "delivered" {

			// Update units sold for each product in the order
			for _, product := range order.Products {
				err = storeHandler.UpdateProductUnitsSold(ctx, product.ID)
				if err != nil {
					log.Printf("Error updating units sold for product %d in order %s: %v",
						product.ID, order.UUID, err)
					errorCount++
					continue
				}
				updatedCount++
			}
		}
	}

	return &model.UpdateUnitsSoldResponse{
		Success:      true,
		UpdatedCount: updatedCount,
		ErrorCount:   errorCount,
	}, nil
}

// SubmitContactForm handles contact form submissions
func (r *mutationResolver) SubmitContactForm(ctx context.Context, input model.ContactFormInput) (string, error) {
	// Initialize email client (using Termii since you have it in your .env)
	termiiAPIKey := os.Getenv("TERMII_API_KEY")
	termiiSecretKey := os.Getenv("TERMII_SECRET_KEY")

	// Create email content
	emailContent := fmt.Sprintf(`
        New Contact Form Submission
        
        Name: %s
        Email: %s
        Phone Number: %s
        Message: %s
    `, input.Name, input.Email, input.PhoneNumber, input.Message)

	// Create the request payload
	payload := map[string]interface{}{
		"api_key":      termiiAPIKey,
		"secret_key":   termiiSecretKey,
		"to":           "contact@alutamarket.com",
		"from":         "Aluta Market <no-reply@alutamarket.com>",
		"subject":      "New Contact Form Submission",
		"html_content": emailContent,
		"type":         "plain",
	}

	// Convert payload to JSON
	jsonData, err := json.Marshal(payload)
	if err != nil {
		return "", fmt.Errorf("failed to marshal JSON: %v", err)
	}

	// Create HTTP request
	req, err := http.NewRequest("POST", "https://api.ng.termii.com/api/email/send", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", fmt.Errorf("failed to create request: %v", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")

	// Create HTTP client with timeout
	client := &http.Client{
		Timeout: time.Second * 10,
	}

	// Send request
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	// Read response body
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %v", err)
	}

	// Check response status
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
	}

	// Parse response
	var result map[string]interface{}
	if err := json.Unmarshal(body, &result); err != nil {
		return "", fmt.Errorf("failed to parse response: %v", err)
	}

	// Check if the email was sent successfully
	if status, ok := result["status"].(string); !ok || status != "success" {
		return "", fmt.Errorf("failed to send email: %v", result["message"])
	}

	return "Contact form submitted successfully", nil
}

// SyncPaystackDVAAccounts is the resolver for the syncPaystackDVAAccounts field.
func (r *mutationResolver) SyncPaystackDVAAccounts(ctx context.Context) (bool, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
	if err := storeHandler.SyncExistingPaystackDVAAccounts(ctx); err != nil {
		return false, fmt.Errorf("failed to sync Paystack DVA accounts: %v", err)
	}
	return true, nil
}

// ProcessStoreWithdrawal is the resolver for the processStoreWithdrawal field.
func (r *mutationResolver) ProcessStoreWithdrawal(ctx context.Context, id string, action string) (bool, error) {
	// Convert string ID to uint32
	withdrawalID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid withdrawal ID: %v", err)
	}

	// Create withdrawal service
	withdrawalService := withdrawal.NewService(withdrawal.NewRepository())

	// Process the withdrawal
	err = withdrawalService.ProcessWithdrawal(ctx, uint32(withdrawalID), action)
	if err != nil {
		return false, fmt.Errorf("failed to process withdrawal: %v", err)
	}

	return true, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
	userHandler := user.NewHandler(user.NewService(user.NewRepository()))
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get all users
	users, err := userHandler.GetUsers(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %v", err)
	}

	// Handle pagination if offset and limit are provided
	start := 0
	if offset != nil {
		start = *offset
	}

	end := len(users)
	if limit != nil {
		if start+*limit < end {
			end = start + *limit
		}
	}

	// Apply pagination
	if start < len(users) {
		users = users[start:end]
	} else {
		users = []*user.User{}
	}

	var userResponses []*model.User
	for _, u := range users {
		active := true
		if u.Active != nil {
			active = *u.Active
		}

		// Convert string to pointer for optional fields
		var dobPtr, genderPtr, avatarPtr *string
		if u.Dob != "" {
			dobPtr = &u.Dob
		}
		if u.Gender != "" {
			genderPtr = &u.Gender
		}
		if u.Avatar != "" {
			avatarPtr = &u.Avatar
		}

		userResponse := &model.User{
			ID:       strconv.FormatInt(int64(u.ID), 10),
			UUID:     u.UUID,
			Fullname: u.Fullname,
			Email:    u.Email,
			Phone:    u.Phone,
			Campus:   u.Campus,
			Usertype: u.Usertype,
			Active:   active,
			Avatar:   avatarPtr,
			Dob:      dobPtr,
			Gender:   genderPtr,
			Online:   u.Online,
		}

		// If user is a seller, fetch their store
		if u.Usertype == "seller" {
			// Get the store for this seller
			userStore, err := storeHandler.GetStore(ctx, u.ID)
			if err == nil && userStore != nil {
				// Convert followers to GraphQL model
				var followers []*model.StoreFollower
				for _, f := range userStore.Followers {
					followers = append(followers, &model.StoreFollower{
						FollowerID:    int(f.FollowerID),
						FollowerName:  f.FollowerName,
						StoreID:       int(f.StoreID),
						FollowerImage: f.FollowerImage,
					})
				}

				storeModel := &model.Store{
					ID:                 strconv.Itoa(int(userStore.ID)),
					Name:               userStore.Name,
					Link:               userStore.Link,
					Description:        userStore.Description,
					Address:            userStore.Address,
					Phone:              userStore.Phone,
					HasPhysicalAddress: userStore.HasPhysicalAddress,
					Thumbnail:          userStore.Thumbnail,
					Background:         userStore.Background,
					Status:             userStore.Status,
					User:               int(userStore.UserID),
					Wallet:             float64(userStore.Wallet),
					Followers:          followers,
				}
				userResponse.Stores = []*model.Store{storeModel}
			}
		}

		userResponses = append(userResponses, userResponse)
	}

	return userResponses, nil
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	result, err := r.UserHandler.GetUser(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %v", err)
	}

	if result == nil {
		return nil, fmt.Errorf("user not found")
	}

	// Convert repository user to GraphQL model with proper type handling
	user := &model.User{
		ID:       strconv.FormatUint(uint64(result.ID), 10),
		UUID:     result.UUID,
		Email:    result.Email,
		Fullname: result.Fullname,
		Phone:    result.Phone,
		Campus:   result.Campus,
		Usertype: result.Usertype,
		Online:   result.Online,
		Active:   *result.Active,
		Twofa:    *result.Twofa,
	}

	// Handle optional string fields
	if result.Avatar != "" {
		user.Avatar = &result.Avatar
	}
	if result.Gender != "" {
		user.Gender = &result.Gender
	}
	if result.Dob != "" {
		user.Dob = &result.Dob
	}

	// Handle tokens
	if result.AccessToken != "" {
		user.AccessToken = &result.AccessToken
	}
	if result.RefreshToken != "" {
		user.RefreshToken = &result.RefreshToken
	}

	// Handle PaymentDetails if they exist
	if result.PaymentDetails.Name != "" {
		user.PaymentDetails = &model.PaymentDetails{
			Name:    result.PaymentDetails.Name,
			Phone:   result.PaymentDetails.Phone,
			Address: result.PaymentDetails.Address,
			Info:    result.PaymentDetails.Info,
		}
	}

	return user, nil
}

// Categories is the resolver for the Categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	categories, err := r.ProductHandler.GetCategories(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch categories: %v", err)
	}

	var result []*model.Category
	for _, cat := range categories {
		// Convert subcategories
		subCategories := make([]*model.SubCategory, 0)
		for _, sub := range cat.SubCategories {
			subCategories = append(subCategories, &model.SubCategory{
				Name:     sub.Name,
				Slug:     sub.Slug,
				Category: int(sub.CategoryID),
			})
		}

		result = append(result, &model.Category{
			ID:            strconv.FormatUint(uint64(cat.ID), 10),
			Name:          cat.Name,
			Slug:          cat.Slug,
			Type:          cat.Type,
			Subcategories: subCategories,
		})
	}
	return result, nil
}

// FollowedStores is the resolver for the FollowedStores field.
func (r *queryResolver) FollowedStores(ctx context.Context, userID int) ([]*model.Store, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Convert int to uint32
	userIDUint := uint32(userID)

	// Get followed stores
	stores, err := storeHandler.GetFollowedStores(ctx, userIDUint)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch followed stores: %v", err)
	}

	// Convert to GraphQL model
	var modelStores []*model.Store
	for _, s := range stores {
		if s == nil {
			continue
		}

		// Convert followers
		var followers []*model.StoreFollower
		for _, f := range s.Followers {
			followers = append(followers, &model.StoreFollower{
				FollowerID:    int(f.FollowerID),
				FollowerName:  f.FollowerName,
				StoreID:       int(f.StoreID),
				FollowerImage: f.FollowerImage,
			})
		}

		// Convert products
		var products []*model.Product
		for _, p := range s.Products {
			products = append(products, &model.Product{
				ID:          int(p.ID),
				Name:        p.Name,
				Price:       p.Price,
				Description: p.Description,
				Discount:    p.Discount,
				Image:       p.Images,
				Slug:        p.Slug,
				Quantity:    p.Quantity,
				Status:      p.Status,
				Thumbnail:   p.Thumbnail,
				Store:       p.Store,
				Category:    p.Category,
				Subcategory: p.Subcategory,
			})
		}

		modelStore := &model.Store{
			ID:                 strconv.Itoa(int(s.ID)),
			Link:               s.Link,
			Name:               s.Name,
			User:               int(s.UserID),
			Description:        s.Description,
			Thumbnail:          s.Thumbnail,
			Phone:              s.Phone,
			Background:         s.Background,
			Address:            s.Address,
			Status:             s.Status,
			HasPhysicalAddress: s.HasPhysicalAddress,
			Wallet:             float64(s.Wallet),
			Visitors:           s.Visitors,
			Followers:          followers,
			Product:            products,
		}
		modelStores = append(modelStores, modelStore)
	}

	return modelStores, nil
}

// SellerOrders is the resolver for the SellerOrders field.
func (r *queryResolver) SellerOrders(ctx context.Context, storeName string) ([]*model.Order, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	orders, err := storeHandler.GetOrdersByStore(ctx, storeName)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch orders: %v", err)
	}

	var result []*model.Order
	for _, order := range orders {
		// Verify transaction status with Paystack if needed
		if order.PaymentGateway == "paystack" && (order.Status == "" || order.Status == "not completed" || order.TransStatus == "not paid") {
			verificationResponse, err := utils.VerifyPaystackTransaction(order.UUID)
			if err == nil && verificationResponse.Status {
				if verificationResponse.Data.Status == "success" {
					// Update to pending if the order is new/empty status or not completed
					err = storeHandler.UpdateOrderStatus(ctx, order.UUID, "pending", "paid")
					if err == nil {
						order.Status = "pending"
						order.TransStatus = "paid"
					}
				}
			}
		}

		// Convert products
		var products []*model.Product
		for _, p := range order.Products {
			products = append(products, &model.Product{
				ID:        int(p.ID),
				Name:      p.Name,
				Price:     p.Price,
				Thumbnail: p.Thumbnail,
				Status:    p.Status == "active",
			})
		}

		// Convert delivery details
		var deliveryDetails *model.DeliveryDetails
		if order.DeliveryDetails != nil {
			deliveryDetails = &model.DeliveryDetails{
				Method:  order.DeliveryDetails.Method,
				Address: order.DeliveryDetails.Address,
				Fee:     order.DeliveryDetails.Fee,
			}
		}

		result = append(result, &model.Order{
			CartID:          int(order.CartID),
			UUID:            order.UUID,
			Amount:          order.Amount,
			Status:          order.Status,
			PaymentGateway:  order.PaymentGateway,
			PaymentMethod:   order.PaymentMethod,
			TransRef:        order.TransRef,
			TransStatus:     order.TransStatus,
			Products:        products,
			DeliveryDetails: deliveryDetails,
			TextRef:         &order.TransRef,
			CreatedAt:       &order.CreatedAt,
		})
	}

	return result, nil
}

// Category is the resolver for the Category field.
func (r *queryResolver) Category(ctx context.Context, id int) (*model.Category, error) {
	categoryID := uint32(id)
	category, err := r.ProductHandler.GetCategory(ctx, categoryID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch category: %v", err)
	}

	if category == nil {
		return nil, fmt.Errorf("category not found")
	}

	// Convert SubCategories to the correct type
	subCategories := make([]*model.SubCategory, 0)
	for _, sub := range category.SubCategories {
		subCategories = append(subCategories, &model.SubCategory{
			Name:     sub.Name,
			Slug:     sub.Slug,
			Category: int(sub.CategoryID),
		})
	}

	return &model.Category{
		ID:            strconv.FormatUint(uint64(category.ID), 10),
		Name:          category.Name,
		Slug:          category.Slug,
		Type:          category.Type,
		Subcategories: subCategories,
	}, nil
}

// SubCategory is the resolver for the SubCategory field.
func (r *queryResolver) SubCategory(ctx context.Context, id string) (*model.SubCategory, error) {
	panic(fmt.Errorf("not implemented: SubCategory - SubCategory"))
}

// Products is the resolver for the Products field.
func (r *queryResolver) Products(ctx context.Context, store *string, categorySlug *string, limit *int, offset *int) (*model.ProductPaginationData, error) {
	fmt.Printf("Received Arguments - limit: %v, offset: %v, store: %v\n", limit, offset, store)

	// Convert nullable parameters
	limitValue := 12
	if limit != nil {
		limitValue = *limit
	}

	offsetValue := 0
	if offset != nil {
		offsetValue = *offset
	}

	storeValue := ""
	if store != nil {
		storeValue = *store
	}

	var products []*product.Product
	var total int
	var err error

	if store != nil && strings.Contains(*store, "-") {
		// This is a search query
		searchQuery := strings.TrimSuffix(*store, "-")
		products, err = r.ProductHandler.SearchProducts(ctx, searchQuery)
		if err != nil {
			return nil, fmt.Errorf("failed to search products: %v", err)
		}
		total = len(products)
	} else {
		products, total, err = r.ProductHandler.GetProducts(ctx, storeValue, "", limitValue, offsetValue)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch products: %v", err)
		}
	}

	if products == nil {
		products = []*product.Product{} // Return empty array instead of nil
	}

	// Convert to GraphQL model
	modelProducts := make([]*model.Product, 0, len(products))
	for _, p := range products {
		if p == nil {
			continue
		}
		modelProducts = append(modelProducts, &model.Product{
			ID:              int(p.ID),
			Name:            p.Name,
			Slug:            p.Slug,
			Description:     p.Description,
			Price:           p.Price,
			Discount:        p.Discount,
			Status:          p.Status,
			Quantity:        p.Quantity,
			Thumbnail:       p.Thumbnail,
			Image:           p.Images,
			File:            &p.File,
			Store:           p.Store,
			Category:        p.Category,
			Subcategory:     p.Subcategory,
			AlwaysAvailable: &p.AlwaysAvailbale,
		})
	}

	return &model.ProductPaginationData{
		Data:        modelProducts,
		CurrentPage: offsetValue + 1,
		PerPage:     limitValue,
		Total:       total,
		NextPage:    offsetValue + 2,
		PrevPage:    offsetValue,
	}, nil
}

// Product is the resolver for the Product field.
func (r *queryResolver) Product(ctx context.Context, id int) (*model.Product, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert int to uint32 for the handler
	productID := uint32(id)

	// Call the handler with userId 0 since we're just viewing
	p, err := productHandler.GetProduct(ctx, productID, 0)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	return &model.Product{
		ID:              int(p.ID),
		Name:            p.Name,
		Slug:            p.Slug,
		Description:     p.Description,
		Type:            &p.Type,
		Price:           p.Price,
		Discount:        p.Discount,
		Status:          p.Status,
		Quantity:        p.Quantity,
		Thumbnail:       p.Thumbnail,
		Image:           p.Images,
		File:            &p.File,
		Store:           p.Store,
		Category:        p.Category,
		Subcategory:     p.Subcategory,
		AlwaysAvailable: &p.AlwaysAvailbale,
		UnitsSold:       p.UnitsSold,
	}, nil
}

// HandledProducts is the resolver for the HandledProducts field.
func (r *queryResolver) HandledProducts(ctx context.Context, user int, typeArg string) ([]*model.HandledProducts, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))

	// Convert int to uint32 for the handler
	userID := uint32(user)

	// Add debug logging
	fmt.Printf("Fetching handled products for user %d with type %s\n", userID, typeArg)

	// Get handled products from the handler
	products, err := productHandler.GetHandledProducts(ctx, userID, typeArg)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch handled products: %v", err)
	}

	// Add debug logging
	fmt.Printf("Found %d products\n", len(products))

	// Initialize empty slice
	handledProducts := make([]*model.HandledProducts, 0)

	// Convert to GraphQL model
	for _, p := range products {
		// Get the actual product details using product ID from handled_products table
		productDetails, err := productHandler.GetProduct(ctx, p.ProductID, 0)
		if err != nil {
			fmt.Printf("Error fetching product details for ID %d: %v\n", p.ProductID, err)
			continue
		}

		if productDetails == nil {
			fmt.Printf("Product details not found for ID %d\n", p.ProductID)
			continue
		}

		status := productDetails.Status
		price := productDetails.Price
		discount := productDetails.Discount
		quantity := productDetails.Quantity
		name := productDetails.Name
		thumbnail := productDetails.Thumbnail

		handledProduct := &model.HandledProducts{
			UserID:           int(p.UserID),
			ProductID:        int(productDetails.ID),
			ProductName:      &name,
			ProductThumbnail: &thumbnail,
			ProductPrice:     &price,
			ProductDiscount:  &discount,
			ProductStatus:    &status,
			ProductQuantity:  &quantity,
		}
		handledProducts = append(handledProducts, handledProduct)

		// Log each product being added
		fmt.Printf("Added product: ID=%d, Name=%s\n", productDetails.ID, name)
	}

	return handledProducts, nil
}

// RecommendedProducts is the resolver for the RecommendedProducts field.
func (r *queryResolver) RecommendedProducts(ctx context.Context, query string) ([]*model.Product, error) {
	panic(fmt.Errorf("not implemented: RecommendedProducts - RecommendedProducts"))
}

// RecentlyAddedProducts is the resolver for the RecentlyAddedProducts field.
func (r *queryResolver) RecentlyAddedProducts(ctx context.Context, user int) ([]*model.Product, error) {
	panic(fmt.Errorf("not implemented: RecentlyAddedProducts - RecentlyAddedProducts"))
}

// Cart is the resolver for the Cart field.
func (r *queryResolver) Cart(ctx context.Context, user int) (*model.Cart, error) {
	cartHandler := cart.NewHandler(cart.NewService(cart.NewRepository()))

	// Convert int to uint32 for the handler
	userID := uint32(user)

	result, err := cartHandler.GetCart(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Convert cart items to GraphQL model
	var cartItems []*model.CartItem
	for _, item := range result.Items {
		cartItem := &model.CartItem{
			Product: &model.Product{
				ID:        int(item.Product.ID),
				Name:      item.Product.Name,
				Price:     item.Product.Price,
				Discount:  item.Product.Discount,
				Quantity:  item.Product.Quantity,
				Thumbnail: item.Product.Thumbnail,
				Image:     item.Product.Images,
				Store:     item.Product.Store,
			},
			Quantity: item.Quantity,
		}
		cartItems = append(cartItems, cartItem)
	}

	// Convert ID to string
	id := strconv.FormatUint(uint64(result.ID), 10)

	return &model.Cart{
		Items:  cartItems,
		Total:  result.Total,
		Active: result.Active,
		User:   int(result.UserID),
		ID:     &id,
	}, nil
}

// SubscriptionBundle is the resolver for the SubscriptionBundle field.
func (r *queryResolver) SubscriptionBundle(ctx context.Context, serviceID string) (*model.SubscriptionBundle, error) {
	panic(fmt.Errorf("not implemented: SubscriptionBundle - SubscriptionBundle"))
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, query string) ([]*model.Product, error) {
	products, err := r.ProductHandler.SearchProducts(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to search products: %v", err)
	}

	// Convert to GraphQL model
	modelProducts := make([]*model.Product, 0, len(products))
	for _, p := range products {
		if p == nil {
			continue
		}
		modelProducts = append(modelProducts, &model.Product{
			ID:              int(p.ID),
			Name:            p.Name,
			Slug:            p.Slug,
			Description:     p.Description,
			Price:           p.Price,
			Discount:        p.Discount,
			Status:          p.Status,
			Quantity:        p.Quantity,
			Thumbnail:       p.Thumbnail,
			Image:           p.Images,
			File:            &p.File,
			Store:           p.Store,
			Category:        p.Category,
			Subcategory:     p.Subcategory,
			AlwaysAvailable: &p.AlwaysAvailbale,
		})
	}

	return modelProducts, nil
}

// Stores is the resolver for the Stores field.
func (r *queryResolver) Stores(ctx context.Context, user *int, limit *int, offset *int) (*model.StorePaginationData, error) {
	// Convert nullable parameters to concrete values
	var userID uint32
	if user != nil {
		userID = uint32(*user)
	}
	limitValue := 100
	if limit != nil {
		limitValue = *limit
	}
	offsetValue := 0
	if offset != nil {
		offsetValue = *offset
	}

	// Get stores from repository
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
	stores, err := storeHandler.GetStores(ctx, userID, limitValue, offsetValue)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch stores: %v", err)
	}

	// Convert to GraphQL model
	var modelStores []*model.Store
	for _, s := range stores {
		if s == nil {
			continue
		}

		// Convert followers
		var followers []*model.StoreFollower
		for _, f := range s.Followers {
			followers = append(followers, &model.StoreFollower{
				FollowerID:    int(f.FollowerID),
				FollowerName:  f.FollowerName,
				StoreID:       int(f.StoreID),
				FollowerImage: f.FollowerImage,
			})
		}

		// Convert products
		var products []*model.Product
		for _, p := range s.Products {
			products = append(products, &model.Product{
				ID:          int(p.ID),
				Name:        p.Name,
				Price:       p.Price,
				Description: p.Description,
				Discount:    p.Discount,
				Image:       p.Images,
				Slug:        p.Slug,
				Quantity:    p.Quantity,
				Status:      p.Status,
				Thumbnail:   p.Thumbnail,
				Store:       p.Store,
				Category:    p.Category,
				UnitsSold:   p.UnitsSold,
				Subcategory: p.Subcategory,
			})
		}

		// Convert withdrawal accounts
		var accounts []*model.WithdrawAccount
		for _, a := range s.Accounts {
			accounts = append(accounts, &model.WithdrawAccount{
				BankCode:      a.BankCode,
				BankName:      a.BankName,
				BankImage:     a.BankImage,
				AccountNumber: a.AccountNumber,
				AccountName:   a.AccountName,
			})
		}

		modelStore := &model.Store{
			ID:                 strconv.Itoa(int(s.ID)), // Convert ID to string
			Link:               s.Link,
			Name:               s.Name,
			User:               int(s.UserID),
			Description:        s.Description,
			Thumbnail:          s.Thumbnail,
			Phone:              s.Phone,
			Background:         s.Background,
			Address:            s.Address,
			Status:             s.Status,
			HasPhysicalAddress: s.HasPhysicalAddress,
			Wallet:             float64(s.Wallet),
			Visitors:           s.Visitors,
			Followers:          followers,
			Product:            products,
			Accounts:           accounts,
			MaintenanceMode:    s.MaintenanceMode,
		}
		modelStores = append(modelStores, modelStore)
	}

	return &model.StorePaginationData{
		Data:        modelStores,
		CurrentPage: offsetValue + 1,
		PerPage:     limitValue,
		Total:       len(modelStores),
	}, nil
}

// Store is the resolver for the Store field.
func (r *queryResolver) Store(ctx context.Context, id int) (*model.Store, error) {
	panic(fmt.Errorf("not implemented: Store - Store"))
}

// Reviews is the resolver for the Reviews field.
func (r *queryResolver) Reviews(ctx context.Context, id string, value string) ([]*model.Review, error) {
	db := database.GetDB()
	if db == nil {
		return nil, fmt.Errorf("database connection failed")
	}

	var reviews []*model.Review

	// Common struct for all review types
	type dbReview struct {
		StoreID   int       `json:"store_id"`
		ProductID int       `json:"product_id"`
		OrderID   string    `json:"order_id"`
		SellerID  int       `json:"seller_id"`
		Rating    float64   `json:"rating"`
		Message   string    `json:"message"`
		CreatedAt time.Time `json:"created_at"`
		UpdatedAt time.Time `json:"updated_at"`
		Nickname  string    `json:"nickname"`
		Avatar    string    `json:"avatar"`
	}

	// Convert ID based on type
	numericID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid %s ID: %v", value, err)
	}

	// Build query based on type
	query := db.Table("reviews").
		Select("reviews.*, users.nickname, users.avatar").
		Joins("LEFT JOIN users ON reviews.buyer_id = users.id")

	// Add type-specific where clause
	switch value {
	case "product":
		query = query.Where("reviews.product_id = ?", numericID)
	case "store":
		query = query.Where("reviews.store_id = ?", numericID)
	case "order":
		query = query.Where("reviews.order_id = ?", numericID)
	default:
		return nil, fmt.Errorf("invalid value parameter: %s", value)
	}

	// Execute query
	var dbReviews []dbReview
	if err := query.Scan(&dbReviews).Error; err != nil {
		return nil, fmt.Errorf("error fetching %s reviews: %v", value, err)
	}

	// Convert to model.Review objects
	for _, r := range dbReviews {
		review := &model.Review{
			StoreID:   r.StoreID,
			ProductID: r.ProductID,
			OrderID:   r.OrderID,
			SellerID:  r.SellerID,
			Rating:    r.Rating,
			Message:   &r.Message,
			CreatedAt: &r.CreatedAt,
			UpdatedAt: &r.UpdatedAt,
			Buyer: &model.ReviewBuyer{
				Nickname: r.Nickname,
				Avatar:   r.Avatar,
				Comment:  r.Message,
			},
		}
		reviews = append(reviews, review)
	}

	return reviews, nil
}

// StoreByName is the resolver for the StoreByName field.
func (r *queryResolver) StoreByName(ctx context.Context, name string) (*model.Store, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get store by name
	s, err := storeHandler.GetStoreByName(ctx, name)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch store: %v", err)
	}

	// Convert followers to GraphQL model
	var followers []*model.StoreFollower
	for _, f := range s.Followers {
		followers = append(followers, &model.StoreFollower{
			FollowerID:    int(f.FollowerID),
			FollowerName:  f.FollowerName,
			StoreID:       int(f.StoreID),
			FollowerImage: f.FollowerImage,
		})
	}

	// Convert products to GraphQL model
	var products []*model.Product
	for _, p := range s.Products {
		products = append(products, &model.Product{
			ID:          int(p.ID),
			Name:        p.Name,
			Price:       p.Price,
			Description: p.Description,
			Discount:    p.Discount,
			Image:       p.Images,
			Slug:        p.Slug,
			Quantity:    p.Quantity,
			Status:      p.Status,
			Thumbnail:   p.Thumbnail,
			Store:       p.Store,
			Category:    p.Category,
			Subcategory: p.Subcategory,
		})
	}

	return &model.Store{
		ID:                 strconv.Itoa(int(s.ID)),
		Link:               s.Link,
		Name:               s.Name,
		User:               int(s.UserID),
		Description:        s.Description,
		Thumbnail:          s.Thumbnail,
		Phone:              s.Phone,
		Background:         s.Background,
		Address:            s.Address,
		Status:             s.Status,
		HasPhysicalAddress: s.HasPhysicalAddress,
		Wallet:             float64(s.Wallet),
		Visitors:           s.Visitors,
		Followers:          followers,
		Product:            products,
	}, nil
}

// PurchasedOrder is the resolver for the PurchasedOrder field.
func (r *queryResolver) PurchasedOrder(ctx context.Context, user int) ([]*model.PurchasedOrder, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Pass the user ID directly as integer
	orders, err := storeHandler.GetPurchasedOrders(ctx, fmt.Sprintf("%d", user))
	if err != nil {
		// Check for specific error types
		switch {
		case strings.Contains(err.Error(), "record not found"):
			// Return empty array if no orders found
			return []*model.PurchasedOrder{}, nil
		case strings.Contains(err.Error(), "<!DOCTYPE"):
			// Return empty array for HTML response
			return []*model.PurchasedOrder{}, nil
		case strings.Contains(err.Error(), "unsupported relations"):
			// Return empty array for relation errors
			return []*model.PurchasedOrder{}, nil
		default:
			return nil, fmt.Errorf("failed to fetch purchased orders: %v", err)
		}
	}

	if orders == nil {
		return []*model.PurchasedOrder{}, nil
	}

	// Rest of the conversion code remains the same
	var purchasedOrders []*model.PurchasedOrder
	for _, order := range orders {
		if order == nil {
			continue
		}

		// Convert tracked products with nil check
		var products []*model.TrackedProduct
		if order.Products != nil {
			for _, p := range order.Products {
				products = append(products, &model.TrackedProduct{
					ID:        int(p.ID),
					Name:      p.Name,
					Price:     p.Price,
					Thumbnail: p.Thumbnail,
					Discount:  p.Discount,
					Status:    p.Status,
				})
			}
		}

		// Convert delivery details with nil check and default values
		var deliveryDetails *model.DeliveryDetails
		if order.DeliveryDetails != nil {
			deliveryDetails = &model.DeliveryDetails{
				Method:  order.DeliveryDetails.Method,
				Address: order.DeliveryDetails.Address,
				Fee:     order.DeliveryDetails.Fee,
			}
		} else {
			// Provide default values when delivery details are missing
			deliveryDetails = &model.DeliveryDetails{
				Method:  "digital", // Default to digital delivery
				Address: "N/A",     // Default address
				Fee:     0,         // Default fee
			}
		}

		// Convert string values to float64
		fee, _ := strconv.ParseFloat(order.Fee, 64)
		amount, _ := strconv.ParseFloat(order.Amount, 64)

		purchasedOrder := &model.PurchasedOrder{
			CartID:          int(order.CartID),
			Coupon:          order.Coupon,
			Fee:             fee,
			Status:          order.Status,
			UserID:          order.UserID,
			Amount:          amount,
			UUID:            order.UUID,
			PaymentGateway:  order.PaymentGateway,
			PaymentMethod:   order.PaymentMethod,
			TransRef:        order.TransRef,
			TransStatus:     order.TransStatus,
			Products:        products,
			CreatedAt:       order.CreatedAt,
			DeliveryDetails: deliveryDetails, // Now this will never be nil
			TextRef:         order.TransRef,
		}
		purchasedOrders = append(purchasedOrders, purchasedOrder)
	}

	return purchasedOrders, nil
}

// Skynets is the resolver for the Skynets field.
func (r *queryResolver) Skynets(ctx context.Context, id string) ([]*model.Skynet, error) {
	panic(fmt.Errorf("not implemented: Skynets - Skynets"))
}

// Skynet is the resolver for the Skynet field.
func (r *queryResolver) Skynet(ctx context.Context, id string) (*model.Skynet, error) {
	panic(fmt.Errorf("not implemented: Skynet - Skynet"))
}

// Mydva is the resolver for the MYDVA field.
func (r *queryResolver) Mydva(ctx context.Context, email string) (*model.Account, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	account, err := storeHandler.GetDVAAccount(ctx, email)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch DVA account: %v", err)
	}

	// Convert string ID to uint64
	id, err := strconv.ParseUint(account.ID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid account ID: %v", err)
	}

	// Convert customer ID to int
	customerID, err := strconv.Atoi(account.Customer.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid customer ID: %v", err)
	}

	// Convert bank ID to int
	bankID, err := strconv.Atoi(account.Bank.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid bank ID: %v", err)
	}

	return &model.Account{
		Customer: &model.Customer{
			ID:        strconv.Itoa(customerID),
			FirstName: account.Customer.Email,
			LastName:  "",
		},
		Bank: &model.Bank{
			ID:   strconv.Itoa(bankID), // Use the converted bankID here
			Name: account.Bank.Name,
			Slug: account.Bank.Slug,
		},
		ID:            strconv.FormatUint(id, 10),
		AccountNumber: account.AccountNumber,
		AccountName:   account.AccountName,
	}, nil
}

// GetDVABalance is the resolver for the GetDVABalance field.
func (r *queryResolver) GetDVABalance(ctx context.Context, accountNumber string, storeID *int) (*string, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get PayStack DVA balance
	paystackBalance, err := storeHandler.GetDVABalance(ctx, accountNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch DVA balance: %v", err)
	}

	totalBalance := paystackBalance

	// If storeID is provided, update store wallet and add store earnings
	if storeID != nil {
		storeRepo := store.NewRepository()
		store, err := storeRepo.GetStore(ctx, uint32(*storeID))
		if err != nil {
			return nil, fmt.Errorf("failed to get store: %v", err)
		}

		// Calculate total balance including released earnings
		earnings, err := storeHandler.GetStoreEarnings(ctx, uint32(*storeID))
		if err == nil {
			// Sum up all released earnings
			for _, earning := range earnings {
				if earning.Status == "released" {
					totalBalance += earning.Amount
				}
			}
		}

		// Get total withdrawals
		var totalWithdrawals float64
		var withdrawals []*shared.Withdrawal
		if err := storeRepo.GetDB().Where("store_id = ? AND status IN ?", *storeID, []string{"pending", "approved", "completed"}).Find(&withdrawals).Error; err == nil {
			// Sum up all withdrawals
			for _, withdrawal := range withdrawals {
				totalWithdrawals += withdrawal.Amount
			}
		}

		// Subtract withdrawals from total balance
		totalBalance -= totalWithdrawals

		// Update store wallet with total balance (Paystack + released earnings - withdrawals)
		if store.Wallet != totalBalance {
			if err := storeRepo.UpdateWallet(ctx, uint32(*storeID), totalBalance-store.Wallet); err != nil {
				return nil, fmt.Errorf("failed to update store wallet: %v", err)
			}
		}
	}

	balanceStr := strconv.FormatFloat(totalBalance, 'f', 2, 64)
	return &balanceStr, nil
}

// MyInvoices is the resolver for the MyInvoices field.
func (r *queryResolver) MyInvoices(ctx context.Context, storeID *int) ([]*model.Invoice, error) {
	panic(fmt.Errorf("not implemented: MyInvoices - MyInvoices"))
}

// MyDownloads is the resolver for the MyDownloads field.
func (r *queryResolver) MyDownloads(ctx context.Context, id string) ([]*model.Downloads, error) {
	panic(fmt.Errorf("not implemented: MyDownloads - MyDownloads"))
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context) ([]*model.User, error) {
	users, err := r.UserHandler.GetUsers(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %v", err)
	}

	log.Printf("Fetched %d users", len(users))

	var userResponses []*model.User
	for _, u := range users {
		log.Printf("Processing user: ID=%d, Type=%s", u.ID, u.Usertype)

		active := true
		if u.Active != nil {
			active = *u.Active
		}

		// Convert string to pointer for Dob fields
		var dobPtr *string
		if u.Dob != "" {
			dobPtr = &u.Dob
		}

		// Convert string to pointer for Gender fields
		var genderPtr *string
		if u.Gender != "" {
			genderPtr = &u.Gender
		}

		// Convert string to pointer for Avatar field
		var avatarPtr *string
		if u.Avatar != "" {
			avatarPtr = &u.Avatar
		}

		userResponse := &model.User{
			ID:       strconv.FormatInt(int64(u.ID), 10),
			UUID:     u.UUID,
			Fullname: u.Fullname,
			Email:    u.Email,
			Phone:    u.Phone,
			Campus:   u.Campus,
			Usertype: u.Usertype,
			Active:   active,
			Avatar:   avatarPtr,
			Dob:      dobPtr,
			Gender:   genderPtr,
			Online:   u.Online,
		}

		// If user is a seller, fetch all their stores
		if u.Usertype == "seller" {
			log.Printf("Fetching stores for seller user ID: %d", u.ID)
			storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
			stores, err := storeHandler.GetStores(ctx, u.ID, 0, 0) // Fetch all stores for this user
			if err != nil {
				log.Printf("Error fetching stores for user %d: %v", u.ID, err)
			} else {
				log.Printf("Found %d stores for user %d", len(stores), u.ID)
				if len(stores) > 0 {
					var storeModels []*model.Store
					for _, s := range stores {
						log.Printf("Processing store: ID=%d, Name=%s", s.ID, s.Name)
						// Convert followers to GraphQL model
						var followers []*model.StoreFollower
						for _, f := range s.Followers {
							followers = append(followers, &model.StoreFollower{
								FollowerID:    int(f.FollowerID),
								FollowerName:  f.FollowerName,
								StoreID:       int(f.StoreID),
								FollowerImage: f.FollowerImage,
							})
						}

						storeModel := &model.Store{
							ID:                 strconv.Itoa(int(s.ID)),
							Name:               s.Name,
							Link:               s.Link,
							Description:        s.Description,
							Address:            s.Address,
							Phone:              s.Phone,
							HasPhysicalAddress: s.HasPhysicalAddress,
							Thumbnail:          s.Thumbnail,
							Background:         s.Background,
							Status:             s.Status,
							User:               int(s.UserID),
							Wallet:             float64(s.Wallet),
							Followers:          followers,
							Email:              s.Email,
							MaintenanceMode:    s.MaintenanceMode,
						}
						storeModels = append(storeModels, storeModel)
					}
					userResponse.Stores = storeModels
				}
			}
		}

		userResponses = append(userResponses, userResponse)
	}

	return userResponses, nil
}

// AllStores is the resolver for the allStores field.
func (r *queryResolver) AllStores(ctx context.Context, limit *int, offset *int) (*model.StorePaginationData, error) {
	// Convert nullable parameters to concrete values
	limitValue := 100
	if limit != nil {
		limitValue = *limit
	}
	offsetValue := 0
	if offset != nil {
		offsetValue = *offset
	}

	// Get all stores from repository with debug logging
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))
	stores, err := storeHandler.GetStores(ctx, 0, limitValue, offsetValue)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch stores: %v", err)
	}

	// Add debug logging
	log.Printf("Retrieved %d stores from database", len(stores))

	// Convert to GraphQL model
	var modelStores []*model.Store
	for _, s := range stores {
		if s == nil {
			log.Printf("Skipping nil store")
			continue
		}

		log.Printf("Processing store: ID=%d, Name=%s", s.ID, s.Name)

		// Convert followers
		var followers []*model.StoreFollower
		for _, f := range s.Followers {
			followers = append(followers, &model.StoreFollower{
				FollowerID:    int(f.FollowerID),
				FollowerName:  f.FollowerName,
				StoreID:       int(f.StoreID),
				FollowerImage: f.FollowerImage,
			})
		}

		// Convert products
		var products []*model.Product
		for _, p := range s.Products {
			products = append(products, &model.Product{
				ID:          int(p.ID),
				Name:        p.Name,
				Price:       p.Price,
				Description: p.Description,
				Discount:    p.Discount,
				Image:       p.Images,
				Slug:        p.Slug,
				Quantity:    p.Quantity,
				Status:      p.Status,
				Thumbnail:   p.Thumbnail,
				Store:       p.Store,
				Category:    p.Category,
				UnitsSold:   p.UnitsSold,
				Subcategory: p.Subcategory,
			})
		}

		// Convert withdrawal accounts
		var accounts []*model.WithdrawAccount
		for _, a := range s.Accounts {
			accounts = append(accounts, &model.WithdrawAccount{
				BankCode:      a.BankCode,
				BankName:      a.BankName,
				BankImage:     a.BankImage,
				AccountNumber: a.AccountNumber,
				AccountName:   a.AccountName,
			})
		}

		modelStore := &model.Store{
			ID:                 strconv.Itoa(int(s.ID)),
			Link:               s.Link,
			Name:               s.Name,
			User:               int(s.UserID),
			Description:        s.Description,
			Thumbnail:          s.Thumbnail,
			Phone:              s.Phone,
			Background:         s.Background,
			Address:            s.Address,
			Status:             s.Status,
			HasPhysicalAddress: s.HasPhysicalAddress,
			Wallet:             float64(s.Wallet),
			Visitors:           s.Visitors,
			Followers:          followers,
			Product:            products,
			Accounts:           accounts,
		}
		modelStores = append(modelStores, modelStore)
		log.Printf("Added store to response: ID=%s, Name=%s", modelStore.ID, modelStore.Name)
	}

	log.Printf("Returning %d stores in response", len(modelStores))

	return &model.StorePaginationData{
		Data:        modelStores,
		CurrentPage: offsetValue + 1,
		PerPage:     limitValue,
		Total:       len(modelStores),
	}, nil
}

// GetAllProducts is the resolver for the getAllProducts field.
func (r *queryResolver) GetAllProducts(ctx context.Context) ([]*model.Product, error) {
	productHandler := product.NewHandler(product.NewService(product.NewRepository()))
	products, err := productHandler.GetAllProducts(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch all products: %v", err)
	}

	var productResponses []*model.Product
	for _, p := range products {
		if p == nil {
			continue
		}

		// Convert images to string array
		var images []string
		if p.Thumbnail != "" {
			images = []string{p.Thumbnail}
		}

		productResponse := &model.Product{
			ID:          int(p.ID),
			Name:        p.Name,
			Description: p.Description,
			Price:       p.Price,
			Discount:    p.Discount,
			Status:      p.Status,
			Image:       images,
			Quantity:    p.Quantity,
			Store:       p.Store, // Store is already a string in the database
			Category:    p.Category,
			Subcategory: p.Subcategory,
			UnitsSold:   p.UnitsSold,
		}
		productResponses = append(productResponses, productResponse)
	}

	return productResponses, nil
}

// GetAllReviews is the resolver for the getAllReviews field.
func (r *queryResolver) GetAllReviews(ctx context.Context) ([]*model.Review, error) {
	db := database.GetDB()
	if db == nil {
		return nil, fmt.Errorf("database connection failed")
	}

	var reviews []*model.Review

	// Query struct for database
	type dbReview struct {
		StoreID   int       `json:"store_id"`
		ProductID int       `json:"product_id"`
		OrderID   string    `json:"order_id"`
		SellerID  int       `json:"seller_id"`
		Rating    float64   `json:"rating"`
		Message   string    `json:"message"`
		CreatedAt time.Time `json:"created_at"`
		UpdatedAt time.Time `json:"updated_at"`
		Nickname  string    `json:"nickname"`
		Avatar    string    `json:"avatar"`
		Comment   string    `json:"comment"`
	}

	// Get all reviews with user information
	var dbReviews []dbReview
	if err := db.Table("reviews").
		Select("reviews.*, users.nickname, users.avatar").
		Joins("LEFT JOIN users ON reviews.buyer_id = users.id").
		Scan(&dbReviews).Error; err != nil {
		return nil, fmt.Errorf("error fetching reviews: %v", err)
	}

	// Convert to model.Review objects
	for _, r := range dbReviews {
		review := &model.Review{
			StoreID:   r.StoreID,
			ProductID: r.ProductID,
			OrderID:   r.OrderID,
			SellerID:  r.SellerID,
			Rating:    r.Rating,
			Message:   &r.Message,
			CreatedAt: &r.CreatedAt,
			UpdatedAt: &r.UpdatedAt,
			Buyer: &model.ReviewBuyer{
				Nickname: r.Nickname,
				Avatar:   r.Avatar,
				Comment:  r.Comment,
			},
		}
		reviews = append(reviews, review)
	}

	return reviews, nil
}

// GetAllOrders is the resolver for the getAllOrders field.
func (r *queryResolver) GetAllOrders(ctx context.Context) ([]*model.Order, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get all orders
	orders, err := storeHandler.GetAllOrders(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch all orders: %v", err)
	}

	var result []*model.Order
	for _, order := range orders {
		// Convert products
		var products []*model.Product
		for _, p := range order.Products {
			products = append(products, &model.Product{
				ID:        int(p.ID),
				Name:      p.Name,
				Price:     p.Price,
				Thumbnail: p.Thumbnail,
				Status:    p.Status == "active",
			})
		}

		// Convert delivery details
		var deliveryDetails *model.DeliveryDetails
		if order.DeliveryDetails != nil {
			deliveryDetails = &model.DeliveryDetails{
				Method:  order.DeliveryDetails.Method,
				Address: order.DeliveryDetails.Address,
				Fee:     order.DeliveryDetails.Fee,
			}
		}

		result = append(result, &model.Order{
			CartID:          int(order.CartID),
			UUID:            order.UUID,
			Amount:          order.Amount,
			Status:          order.Status,
			PaymentGateway:  order.PaymentGateway,
			PaymentMethod:   order.PaymentMethod,
			TransRef:        order.TransRef,
			TransStatus:     order.TransStatus,
			Products:        products,
			DeliveryDetails: deliveryDetails,
			TextRef:         &order.TransRef,
			CreatedAt:       &order.CreatedAt,
		})
	}

	return result, nil
}

// Add/Update the Chats query resolver
func (r *queryResolver) Chats(ctx context.Context, userID string) ([]*model.Chat, error) {
	// Convert userID string to uint32
	uid, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %v", err)
	}

	// Use GetChatLists instead of GetChatsByUserID
	chats, err := r.MessageHandler.GetChatLists(ctx, uint32(uid))
	if err != nil {
		return nil, fmt.Errorf("failed to get user chats: %v", err)
	}

	var result []*model.Chat
	for _, chat := range chats {
		var messages []*model.Message
		for _, msg := range chat.Messages {
			// Get user details for the sender
			senderUser, err := r.UserHandler.GetUser(ctx, strconv.FormatUint(uint64(msg.Sender), 10))
			if err != nil {
				log.Printf("Error fetching user details: %v", err)
				continue
			}

			var mediaStr *string
			if msg.Media != nil {
				s := string(*msg.Media)
				mediaStr = &s
			}

			// Create user model
			user := &model.User{
				ID:       strconv.FormatUint(uint64(senderUser.ID), 10),
				Fullname: senderUser.Fullname,
				Avatar:   &senderUser.Avatar,
				Online:   senderUser.Online,
			}

			messages = append(messages, &model.Message{
				ID:        strconv.FormatInt(int64(msg.ID), 10),
				ChatID:    strconv.FormatInt(int64(msg.ChatID), 10),
				Content:   msg.Content,
				Sender:    strconv.FormatInt(int64(msg.Sender), 10),
				Media:     mediaStr,
				IsRead:    msg.IsRead,
				Users:     []*model.User{user}, // Add user details here
				CreatedAt: msg.CreatedAt.Format(time.RFC3339),
				UpdatedAt: func() *string {
					if !msg.UpdatedAt.IsZero() {
						t := msg.UpdatedAt.Format(time.RFC3339)
						return &t
					}
					return nil
				}(),
			})
		}

		result = append(result, &model.Chat{
			ID:            strconv.FormatInt(int64(chat.ID), 10),
			Messages:      messages,
			LatestMessage: nil, // Add latest message if needed
			UnreadCount:   chat.UnreadCount,
		})
	}

	return result, nil
}

// Fix the Messages query resolver
func (r *queryResolver) Messages(ctx context.Context, chatID string) ([]*model.Message, error) {
	messages, err := r.MessageHandler.GetMessages(ctx, chatID)
	if err != nil {
		return nil, err
	}

	var result []*model.Message
	for _, msg := range messages {
		createdAt := msg.CreatedAt.Format(time.RFC3339)
		var updatedAt *string
		if !msg.UpdatedAt.IsZero() {
			t := msg.UpdatedAt.Format(time.RFC3339)
			updatedAt = &t
		}

		result = append(result, &model.Message{
			ID:        strconv.FormatInt(int64(msg.ID), 10),
			ChatID:    strconv.FormatInt(int64(msg.ChatID), 10),
			Content:   msg.Content,
			Sender:    strconv.FormatInt(int64(msg.Sender), 10),
			Media:     (*string)(msg.Media),
			IsRead:    msg.IsRead,
			CreatedAt: createdAt,
			UpdatedAt: updatedAt,
		})
	}

	return result, nil
}

// Subscribers is the resolver for the subscribers field.
func (r *queryResolver) Subscribers(ctx context.Context) ([]*model.Subscriber, error) {
	panic(fmt.Errorf("not implemented: Subscribers - subscribers"))
}

// GetDVAAccount is the resolver for the GetDVAAccount field.
func (r *queryResolver) GetDVAAccount(ctx context.Context, userID string) (*model.DVAAccount, error) {
	// Get DVA account details using the userID string directly
	dvaAccount, err := r.UserHandler.GetDVAAccount(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get DVA account: %v", err)
	}

	// Check if dvaAccount or its nested fields are nil
	if dvaAccount == nil {
		return nil, fmt.Errorf("DVA account not found")
	}

	// Convert to GraphQL model
	return &model.DVAAccount{
		ID:            dvaAccount.ID,
		AccountName:   dvaAccount.AccountName,
		AccountNumber: dvaAccount.AccountNumber,
		Customer: &model.Customer{
			ID:        dvaAccount.Customer.ID,
			Email:     dvaAccount.Customer.Email,
			FirstName: "",
			LastName:  "",
		},
		Bank: &model.Bank{ // Changed from DVABank to Bank
			ID:   dvaAccount.Bank.ID,
			Name: dvaAccount.Bank.Name,
			Slug: dvaAccount.Bank.Slug,
		},
	}, nil
}

// GetStoreEarnings is the resolver for the getStoreEarnings field.
func (r *queryResolver) GetStoreEarnings(ctx context.Context, storeID int) ([]*model.StoreEarnings, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get store earnings
	earnings, err := storeHandler.GetStoreEarnings(ctx, uint32(storeID))
	if err != nil {
		return nil, fmt.Errorf("failed to fetch store earnings: %v", err)
	}

	// Convert to GraphQL model
	var result []*model.StoreEarnings
	for _, e := range earnings {
		result = append(result, &model.StoreEarnings{
			ID:              strconv.FormatUint(uint64(e.ID), 10),
			StoreID:         int(e.StoreID),
			OrderID:         e.OrderID,
			Amount:          e.Amount,
			Status:          e.Status,
			TransactionType: e.TransactionType,
			CreatedAt:       e.CreatedAt,
			UpdatedAt:       e.UpdatedAt,
		})
	}

	return result, nil
}

// CheckStoreEarningsDiscrepancy is the resolver for the checkStoreEarningsDiscrepancy field.
func (r *queryResolver) CheckStoreEarningsDiscrepancy(ctx context.Context, storeID int) (*model.StoreEarningsDiscrepancy, error) {
	storeHandler := store.NewHandler(store.NewService(store.NewRepository()))

	// Get discrepancy information
	deliveredOrdersCount, totalEarnings, err := storeHandler.CheckStoreEarningsDiscrepancy(ctx, uint32(storeID))
	if err != nil {
		return nil, fmt.Errorf("failed to check store earnings discrepancy: %v", err)
	}

	return &model.StoreEarningsDiscrepancy{
		DeliveredOrdersCount: deliveredOrdersCount,
		TotalEarnings:        totalEarnings,
	}, nil
}

// GetWithdrawalsForAdmin is the resolver for the getWithdrawalsForAdmin field.
func (r *queryResolver) GetWithdrawalsForAdmin(ctx context.Context, status *string) ([]*model.AdminWithdrawal, error) {
	widrawalService := withdrawal.NewService(withdrawal.NewRepository())
	storeRepo := store.NewRepository() // Need store repo to get store names

	// Fetch withdrawals using the new service method
	withdrawals, err := widrawalService.GetWithdrawals(ctx, status)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch withdrawals: %v", err)
	}

	var adminWithdrawals []*model.AdminWithdrawal
	for _, w := range withdrawals {
		// Fetch store name for each withdrawal
		storeObj, err := storeRepo.GetStore(ctx, w.StoreID)
		sellerName := "Unknown Seller" // Default value
		if err == nil {
			sellerName = storeObj.Name
		} else {
			log.Printf("Warning: Failed to get store for withdrawal %d (storeID %d): %v", w.ID, w.StoreID, err)
		}

		adminWithdrawals = append(adminWithdrawals, &model.AdminWithdrawal{
			ID:            strconv.FormatUint(uint64(w.ID), 10),
			SellerName:    sellerName,
			AccountNumber: w.AccountNumber,
			BankName:      w.BankName,
			Amount:        w.Amount,
			Time:          w.CreatedAt.Format("03:04PM"),    // Format time
			Date:          w.CreatedAt.Format("02-01-2006"), // Format date
			Status:        w.Status,
			StoreID:       strconv.FormatUint(uint64(w.StoreID), 10),
		})
	}

	return adminWithdrawals, nil
}

// GetWithdrawalDetails is the resolver for the getWithdrawalDetails field.
func (r *queryResolver) GetWithdrawalDetails(ctx context.Context, id string) (*model.AdminWithdrawal, error) {
	widrawalService := withdrawal.NewService(withdrawal.NewRepository())
	storeRepo := store.NewRepository() // Need store repo to get store names

	// Convert the ID string to uint32
	widrawalID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid withdrawal ID: %v", err)
	}

	// Fetch the specific withdrawal using the service method
	w, err := widrawalService.GetWithdrawal(ctx, uint32(widrawalID))
	if err != nil {
		return nil, fmt.Errorf("failed to fetch withdrawal details: %v", err)
	}

	// Fetch store name for the withdrawal
	storeObj, err := storeRepo.GetStore(ctx, w.StoreID)
	sellerName := "Unknown Seller" // Default value
	if err == nil {
		sellerName = storeObj.Name
	} else {
		log.Printf("Warning: Failed to get store for withdrawal %d (storeID %d): %v", w.ID, w.StoreID, err)
	}

	// Map the withdrawal data to the AdminWithdrawal type
	adminWithdrawal := &model.AdminWithdrawal{
		ID:            strconv.FormatUint(uint64(w.ID), 10),
		SellerName:    sellerName,
		AccountNumber: w.AccountNumber,
		BankName:      w.BankName,
		Amount:        w.Amount,
		Time:          w.CreatedAt.Format("03:04PM"),    // Format time
		Date:          w.CreatedAt.Format("02-01-2006"), // Format date
		Status:        w.Status,
		StoreID:       strconv.FormatUint(uint64(w.StoreID), 10),
	}

	return adminWithdrawal, nil
}

// ProductSearchResults is the resolver for the productSearchResults field.
func (r *subscriptionResolver) ProductSearchResults(ctx context.Context, query string) (<-chan []*model.Product, error) {
	panic(fmt.Errorf("not implemented: ProductSearchResults - productSearchResults"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
