package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"
	"strconv"
	"github.com/Chrisentech/aluta-market-api/app"
	"github.com/Chrisentech/aluta-market-api/graph/model"
	"github.com/Chrisentech/aluta-market-api/internals/cart"
	"github.com/Chrisentech/aluta-market-api/internals/product"
	"github.com/Chrisentech/aluta-market-api/internals/user"
	"github.com/Chrisentech/aluta-market-api/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)

	userReq := &user.CreateUserReq{
		Fullname:  input.Fullname,
		Email:     input.Email,
		Campus:    input.Campus,
		Password:  input.Password,
		Phone:     input.Phone,
		Usertype:  input.Usertype,
		// StoreName: *input.Store,
		// StoreLink: *input.Link,
		// Code:       input.Code,
		// Codeexpiry: input.Codeexpiry,
	}
	resp, err := userHandler.CreateUser(ctx, userReq)

	if err != nil {
		return nil, err
	}
	fmt.Println(&resp.Data)
	user := &model.User{
		Fullname: input.Fullname,
		Email:    input.Email,
		Campus:   input.Campus,
		Password: input.Password,
		Phone:    input.Phone,
		Usertype: input.Usertype,
	}
	// Append the newly created store to the user's Stores slice
	// user.Stores = input.Stores

	// user.Stores = append(user.Stores,input.St)
	return user, nil
}

// CreateVerifyOtp is the resolver for the createVerifyOTP field.
func (r *mutationResolver) CreateVerifyOtp(ctx context.Context, input model.NewVerifyOtp) (*model.User, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)

	req := &user.User{
		Phone: input.Phone,
		// Email: *input.Email,
		Code: input.Code,
	}
	resp, err := userHandler.VerifyOTP(ctx, req)
	if err != nil {
		return nil, err
	}
	schema := &model.User{
		Fullname: resp.Fullname,
		Email:    resp.Email,
		Campus:   resp.Campus,
		Password: resp.Password,
		Phone:    resp.Phone,
		Usertype: resp.Usertype,
		Active:   resp.Active,
	}
	return schema, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginReq) (*model.LoginRes, error) {
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}

	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	req := &user.LoginUserReq{
		Email:    input.Email,
		Password: input.Password,
	}
	resp, err := userHandler.Login(ctx, req)
	if err != nil {
		return nil, err
	}
	schema := &model.LoginRes{
		ID:           int(resp.ID),
		AccessToken:  resp.AccessToken,
		RefreshToken: resp.RefreshToken,
	}
	return schema, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.NewCategory) (*model.Category, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newCategory := &product.Category{
		Name: input.Name,
	}
	resp, err := productHandler.CreateCategory(ctx, newCategory)
	if err != nil {
		return nil, err
	}
	schema := &model.Category{
		Name: resp.Name,
		Slug: utils.GenerateSlug(resp.Name),
	}
	return schema, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.NewProduct) (*model.Product, error) {
	// var newProduct *
	// panic(fmt.Errorf("not implemented: CreateProduct - createProduct"))
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)

	newProduct := &product.Product{
		Name:          input.Name,
		Description:   input.Description,
		Image:         input.Image,
		Price:         input.Price,
		Status:        true,
		Slug:          utils.GenerateSlug(input.Name),
		Variant:       input.Variant,
		StoreID:       uint32(input.Store),
		SubCategoryID: uint8(input.Subcategory),
		CategoryID:    uint8(input.Category),
	}
	resp, err := productHandler.CreateProduct(ctx, newProduct)
	if err != nil {
		return nil, err
	}
	schema := &model.Product{
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Image,
		Price:       resp.Price,
		Status:      true,
		Slug:        utils.GenerateSlug(resp.Name),
		// Variant:     string(resp.Variant),

		Store:       int(resp.StoreID),
		Subcategory: int(resp.SubCategoryID),
		Category:    int(resp.CategoryID),
	}
	return schema, nil
}

// CreateSubCategory is the resolver for the createSubCategory field.
func (r *mutationResolver) CreateSubCategory(ctx context.Context, input model.NewSubCategory) (*model.SubCategory, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	newSubCategory := product.SubCategory{
		Name:       input.Name,
		CategoryID: uint32(input.Category),
	}
	resp, err := productHandler.CreateSubCategory(ctx, newSubCategory)
	if err != nil {
		return nil, err
	}
	schema := &model.SubCategory{
		Name:     resp.Name,
		Slug:     utils.GenerateSlug(resp.Name),
		Category: input.Category,
	}
	return schema, nil
}

// AddToCart is the resolver for the addToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, input []*model.AddToCartItemInput) (*model.Cart, error) {
	cartRep := app.InitializePackage(app.CartPackage)

	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)

	var cartItems []*cart.CartItems

	resp, err := cartHandler.AddToCart(ctx, cartItems, uint32(input[0].User))

	if err != nil {
		// Handle the error, possibly by logging it or returning it to the client
		return nil, err
	}
	// Now you need to construct the cart object with the accumulated cartItems
	newCart := &model.Cart{
		// Set the appropriate values for Total, User, and Active
		Total:  resp.Total,       // Replace with the actual total
		User:   int(resp.UserID), // Replace with the actual user ID
		Active: true,             // Replace with the actual active status
		Items:  nil,
	}

	return newCart, nil
}

// UpdateCartItemQuantity is the resolver for the updateCartItemQuantity field.
func (r *mutationResolver) UpdateCartItemQuantity(ctx context.Context, productID string, quantity int) (*model.Cart, error) {
	panic(fmt.Errorf("not implemented: UpdateCartItemQuantity - updateCartItemQuantity"))
}

// RemoveFromCart is the resolver for the removeFromCart field.
func (r *mutationResolver) RemoveFromCart(ctx context.Context, productID string) (*model.Cart, error) {
	panic(fmt.Errorf("not implemented: RemoveFromCart - removeFromCart"))
}

// Users is the resolver for the Users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	// if err := godotenv.Load(); err != nil {
	// 	log.Fatalf("Error loading .env file: %v", err)
	// }
	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	resp, err := userHandler.GetUsers(ctx)
	if err != nil {
		return nil, err
	}

	var users []*model.User

	// Assuming resp is a slice of users
	for _, item := range resp {
		accessToken := item.AccessToken
		refreshToken := item.RefreshToken
		user := &model.User{
			ID:           strconv.FormatInt(int64(item.ID), 10),
			Fullname:     item.Fullname,
			Campus:       item.Campus,
			Email:        item.Email,
			Phone:        item.Phone,
			Twofa:        item.Twofa,
			Active:       item.Active,
			AccessToken:  &accessToken,
			RefreshToken: &refreshToken,
			Usertype:     item.Usertype,
			Code:         item.Code,
			// Codeexpiry: item.Codeexpiry.Format(time.RFC3339),
			Password: "lol......what do y'need it for?",
		}
		users = append(users, user)
	}

	return users, nil
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// if err := godotenv.Load(); err != nil {
	// 	log.Fatalf("Error loading .env file: %v", err)
	// }

	userRep := app.InitializePackage(app.UserPackage)
	userRepository, ok := userRep.(user.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("userRep is not a user.Repository")
	}
	userSrvc := user.NewService(userRepository)
	userHandler := user.NewHandler(userSrvc)
	resp, err := userHandler.GetUser(ctx, id)
	if err != nil {
		return nil, err
	}
	accessToken := resp.AccessToken
	refreshToken := resp.RefreshToken

	user := &model.User{
		ID:           strconv.FormatInt(int64(resp.ID), 10),
		Fullname:     resp.Fullname,
		Campus:       resp.Campus,
		Email:        resp.Email,
		Phone:        resp.Phone,
		Twofa:        resp.Twofa,
		Active:       resp.Active,
		AccessToken:  &accessToken,
		RefreshToken: &refreshToken,
		Usertype:     resp.Usertype,
		Code:         resp.Code,
		// Stores: resp.Stores,
		// Codeexpiry: resp.Codeexpiry.Format(time.RFC3339),
		Password: "lol......what do y'need it for?",
	}
// user.Stores = append(resp)
	return user, nil
}

// Categories is the resolver for the Categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetCategories(ctx)
	if err != nil {
		return nil, err
	}

	var categories []*model.Category

	// Assuming resp is a slice of categories
	for _, item := range resp {
		var subCategories []*model.SubCategory

		for _, subItem := range item.SubCategories {
			subCategory := &model.SubCategory{
				Name:     subItem.Name,
				Slug:     subItem.Slug,
				Category: int(subItem.CategoryID),
			}
			subCategories = append(subCategories, subCategory)
		}

		category := &model.Category{
			Name:          item.Name,
			Slug:          item.Slug,
			SubCategories: subCategories,
		}
		categories = append(categories, category)
	}
	return categories, nil
}

// Products is the resolver for the Products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetProducts(ctx)
	if err != nil {
		return nil, err
	}

	var products []*model.Product

	// Assuming resp is a slice of products
	for _, item := range resp {
		product := &model.Product{
			// ID:       strconv.FormatInt(int64(item.ID), 10),
			Name:        item.Name,
			Description: item.Description,
			Image:       item.Image,
			Price:       item.Price,
			Status:      item.Status,
			Quantity:    item.Quantity,
			Slug:        item.Slug,
			Variant:     item.Variant,
			Condition:   item.Condition,
			Store:       int(item.StoreID),
			Category:    int(item.CategoryID),
		}
		products = append(products, product)
	}

	return products, nil
}

// Product is the resolver for the Product field.
func (r *queryResolver) Product(ctx context.Context, id int) (*model.Product, error) {
	productRep := app.InitializePackage(app.ProductPackage)

	productRepository, ok := productRep.(product.Repository)
	if !ok {
		// Handle the case where the conversion failed
		return nil, fmt.Errorf("productRep is not a product.Repository")
	}
	productSrvc := product.NewService(productRepository)
	productHandler := product.NewHandler(productSrvc)
	resp, err := productHandler.GetProduct(ctx, uint32(id))
	if err != nil {
		return nil, err
	}

	product := &model.Product{
		// ID:       strconv.FormatInt(int64(resp.ID), 10),
		Name:        resp.Name,
		Description: resp.Description,
		Image:       resp.Image,
		Price:       resp.Price,
		Status:      resp.Status,
		Quantity:    resp.Quantity,
		Slug:        resp.Slug,
		Variant:     resp.Variant,
		Condition:   resp.Condition,
		Store:       int(resp.StoreID),
		Category:    int(resp.CategoryID),
	}

	return product, nil
}

// Category is the resolver for the Category field.
func (r *queryResolver) Category(ctx context.Context, id int) (*model.Category, error) {
	panic(fmt.Errorf("not implemented: Category - Category"))
}

// SubCategory is the resolver for the SubCategory field.
func (r *queryResolver) SubCategory(ctx context.Context, id string) (*model.SubCategory, error) {
	panic(fmt.Errorf("not implemented: SubCategory - SubCategory"))
}

// Cart is the resolver for the Cart field.
func (r *queryResolver) Cart(ctx context.Context, user int) (*model.Cart, error) {
	cartRep := app.InitializePackage(app.CartPackage)
	cartRepository, ok := cartRep.(cart.Repository)
	if !ok {
		// Handle the case where the conversion failed
		panic("cartRep is not a cart.Repository")
	}
	cartSrvc := cart.NewService(cartRepository)
	cartHandler := cart.NewHandler(cartSrvc)
	resp, err := cartHandler.GetCart(ctx, uint32(user))
	if err != nil {
		return nil, err
	}
	items := make([]*model.CartItem, len(resp.Items))
	// for i, cartItem := range resp.Items {
	// 	items[i] = &model.CartItem{Quantity: int(cartItem.Quantity)}
	// }

	cart := &model.Cart{
		Total:  resp.Total,
		Active: resp.Active,
		User:   int(resp.UserID),
		Items:  items,
	}
	return cart, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
